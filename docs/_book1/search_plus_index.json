{"./":{"url":"./","title":"介绍","keywords":"","body":"notes "},"java/java.html":{"url":"java/java.html","title":"Java","keywords":"","body":"Java 初始化类的顺序 Java 初始化类的顺序：父类的静态字段 > 父类静态代码块 > 子类静态字段 > 子类静态代码块 > 父类成员变量 > 父类构造代码块 > 父类构造器 > 子类成员变量 > 子类构造代码块 > 子类构造器 。 HTTP 状态码 200 OK - [GET]：服务器成功返回用户请求的数据 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功 204 NO CONTENT - [DELETE]：用户删除数据成功 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作 401 UNAUTHORIZED：表示用户没有权限（令牌、用户名、密码错误） 404 NOT FOUND：用户发出的请求针对的是不存在的记录，服务器没有进行操作 500 INTERNAL SERVER ERROR：服务器发生错误，用户将无法判断发出的请求是否成功 "},"java/graphics2d.html":{"url":"java/graphics2d.html","title":"Graphics2D","keywords":"","body":"坐标系 getAscent() 是 FontMetrics 中的一个方法，（基线-升部线的距离） getDescent() 是 FontMetrics 中的一个方法，（基线-降部线的距离） getHeight() 是 FontMetrics 中的一个方法，（升部线-降部线的距离） g2d.drawString 指定的位置是基线的位置 一个字体中存在着很多假想的“线”，它们决定了该字体文字的显示效果。借用一幅图片说明： Graphics2D 常用 API 创建 Graphics2D 对象 // 创建图片对象 BufferedImage bi = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_4BYTE_ABGR); // 基于图片对象打开绘图 Graphics2D g2d = bi.createGraphics(); 设置抗锯齿 常用的前置设置(不设置线段/文字不是横竖（就是斜的）的时候会有锯齿) // 消除文字锯齿 g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_ON); // 消除画图锯齿 g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); 使用高质量压缩 // 使用高质量压缩 g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY); "},"android/android.html":{"url":"android/android.html","title":"Android","keywords":"","body":"hello android System.out.println(\"sdfdf\"); System.out.println(\"sdfdf\"); System.out.println(\"sdfdf\"); System.out.println(\"sdfdf\"); System.out.println(\"sdfdf\"); System.out.println(\"sdfdf\"); System.out.println(\"sdfdf\"); System.out.println(\"sdfdf\"); System.out.println(\"sdfdf\"); "},"kotlin/kotlin.html":{"url":"kotlin/kotlin.html","title":"Kotlin","keywords":"","body":"Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift，由 JetBrains 设计开发并开源。 Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。 在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。 "},"kotlin/basic_syntax.html":{"url":"kotlin/basic_syntax.html","title":"基本语法","keywords":"","body":"基本语法 包的定义与导入 包的声明应处于源文件顶部： package my.demo import kotlin.text.* // …… 目录与包的结构无需匹配：源代码可以在文件系统的任意位置。 程序入口点 Kotlin 应用程序的入口点是 main 函数。 fun main() { println(\"Hello world!\") } 函数 带有两个 Int 参数、返回 Int 的函数： fun sum(a: Int, b: Int): Int { return a + b } 将表达式作为函数体、返回值类型自动推断的函数： fun sum(a: Int, b: Int) = a + b 函数返回无意义的值： fun printSum(a: Int, b: Int): Unit { println(\"sum of $a and $b is ${a + b}\") } Unit 返回类型可以省略： fun printSum(a: Int, b: Int) { println(\"sum of $a and $b is ${a + b}\") } 变量 定义只读局部变量使用关键字 val 定义。只能为其赋值一次。 val a: Int = 1 // 立即赋值 val b = 2 // 自动推断出 `Int` 类型 val c: Int // 如果没有初始值类型不能省略 c = 3 // 明确赋值 可重新赋值的变量使用 var 关键字： var x = 5 // 自动推断出 `Int` 类型 x += 1 顶层变量： val PI = 3.14 var x = 0 fun incrementX() { x += 1 } 注释 与大多数现代语言一样，Kotlin 支持单行（或行末）与多行（块）注释。 // 这是一个行注释 /* 这是一个多行的 块注释。 */ Kotlin 中的块注释可以嵌套。 /* 注释从这里开始 /* 包含嵌套的注释 */ 并且在这里结束。 */ 字符串模板 var a = 1 // 模板中的简单名称： val s1 = \"a is $a\" a = 2 // 模板中的任意表达式： val s2 = \"${s1.replace(\"is\", \"was\")}, but now is $a\" 条件表达式 fun maxOf(a: Int, b: Int): Int { if (a > b) { return a } else { return b } } 在 Kotlin 中，if 也可以用作表达式： fun maxOf(a: Int, b: Int) = if (a > b) a else b 空值与 null 检测 当某个变量的值可以为 null 的时候，必须在声明处的类型后添加 ? 来标识该引用可为空。 如果 str 的内容不是数字返回 null： fun parseInt(str: String): Int? { // …… } 使用返回可空值的函数: fun printProduct(arg1: String, arg2: String) { val x = parseInt(arg1) val y = parseInt(arg2) // 直接使用 `x * y` 会导致编译错误，因为它们可能为 null if (x != null && y != null) { // 在空检测后，x 与 y 会自动转换为非空值（non-nullable） println(x * y) } else { println(\"'$arg1' or '$arg2' is not a number\") } } 或者 // …… if (x == null) { println(\"Wrong number format in arg1: '$arg1'\") return } if (y == null) { println(\"Wrong number format in arg2: '$arg2'\") return } // 在空检测后，x 与 y 会自动转换为非空值 println(x * y) 类型检测与自动类型转换 is 运算符检测一个表达式是否某类型的一个实例。 如果一个不可变的局部变量或属性已经判断出为某类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换： fun getStringLength(obj: Any): Int? { if (obj is String) { // `obj` 在该条件分支内自动转换成 `String` return obj.length } // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型 return null } 或者 fun getStringLength(obj: Any): Int? { if (obj !is String) return null // `obj` 在这一分支自动转换为 `String` return obj.length } 甚至 fun getStringLength(obj: Any): Int? { // `obj` 在 `&&` 右边自动转换成 `String` 类型 if (obj is String && obj.length > 0) { return obj.length } return null } for 循环 val items = listOf(\"apple\", \"banana\", \"kiwifruit\") for (item in items) { println(item) } 或者 val items = listOf(\"apple\", \"banana\", \"kiwifruit\") for (index in items.indices) { println(\"item at $index is ${items[index]}\") } while 循环 val items = listOf(\"apple\", \"banana\", \"kiwifruit\") var index = 0 while (index when 表达式 fun describe(obj: Any): String = when (obj) { 1 -> \"One\" \"Hello\" -> \"Greeting\" is Long -> \"Long\" !is String -> \"Not a string\" else -> \"Unknown\" } 使用区间（range） 使用 in 运算符来检测某个数字是否在指定区间内： val x = 10 val y = 9 if (x in 1..y+1) { println(\"fits in range\") } 检测某个数字是否在指定区间外: val list = listOf(\"a\", \"b\", \"c\") if (-1 !in 0..list.lastIndex) { println(\"-1 is out of range\") } if (list.size !in list.indices) { println(\"list size is out of valid list indices range, too\") } 区间迭代: for (x in 1..5) { print(x) } 或数列迭代： for (x in 1..10 step 2) { print(x) } println() for (x in 9 downTo 0 step 3) { print(x) } 集合 对集合进行迭代: for (item in items) { println(item) } 使用 in 运算符来判断集合内是否包含某实例： when { \"orange\" in items -> println(\"juicy\") \"apple\" in items -> println(\"apple is fine too\") } 使用 lambda 表达式来过滤（filter）与映射（map）集合： val fruits = listOf(\"banana\", \"avocado\", \"apple\", \"kiwifruit\") fruits .filter { it.startsWith(\"a\") } .sortedBy { it } .map { it.toUpperCase() } .forEach { println(it) } 创建基本类及其实例 val rectangle = Rectangle(5.0, 2.0) val triangle = Triangle(3.0, 4.0, 5.0) "},"kotlin/idiomatic_usage.html":{"url":"kotlin/idiomatic_usage.html","title":"习惯用法","keywords":"","body":"习惯用法 一些在 Kotlin 中广泛使用的语法习惯。 创建 DTOs（POJOs/POCOs） data class Customer(val name: String, val email: String) 会为 Customer 类提供以下功能： 所有属性的 getters （对于 var 定义的还有 setters） equals() hashCode() toString() copy() 所有属性的 component1()、 component2()……等等（参见数据类） 函数的默认参数 fun foo(a: Int = 0, b: String = \"\") { …… } 过滤 list val positives = list.filter { x -> x > 0 } 或者可以更短: val positives = list.filter { it > 0 } 检测元素是否存在于集合中 if (\"john@example.com\" in emailsList) { …… } if (\"jane@example.com\" !in emailsList) { …… } 字符串内插 println(\"Name $name\") 类型判断 when (x) { is Foo //-> …… is Bar //-> …… else //-> …… } 遍历 map/pair 型 list for ((k, v) in map) { println(\"$k -> $v\") } k、v 可以改成任意名字。 使用区间 for (i in 1..100) { …… } // 闭区间：包含 100 for (i in 1 until 100) { …… } // 半开区间：不包含 100 for (x in 2..10 step 2) { …… } for (x in 10 downTo 1) { …… } if (x in 1..10) { …… } 只读 list val list = listOf(\"a\", \"b\", \"c\") 只读 map val map = mapOf(\"a\" to 1, \"b\" to 2, \"c\" to 3) 访问 map println(map[\"key\"]) map[\"key\"] = value 延迟属性 val p: String by lazy { // 计算该字符串 } 扩展函数 fun String.spaceToCamelCase() { …… } \"Convert this to camelcase\".spaceToCamelCase() 创建单例 object Resource { val name = \"Name\" } If not null 缩写 val files = File(\"Test\").listFiles() println(files?.size) If not null and else 缩写 val files = File(\"Test\").listFiles() println(files?.size ?: \"empty\") if null 执行一个语句 val values = …… val email = values[\"email\"] ?: throw IllegalStateException(\"Email is missing!\") 在可能会空的集合中取第一元素 val emails = …… // 可能会是空集合 val mainEmail = emails.firstOrNull() ?: \"\" if not null 执行代码 val value = …… value?.let { …… // 代码会执行到此处, 假如data不为null } 映射可空值（如果非空的话） val value = …… val mapped = value?.let { transformValue(it) } ?: defaultValue // 如果该值或其转换结果为空，那么返回 defaultValue。 返回 when 表达式 fun transform(color: String): Int { return when (color) { \"Red\" -> 0 \"Green\" -> 1 \"Blue\" -> 2 else -> throw IllegalArgumentException(\"Invalid color param value\") } } try/catch 表达式 fun test() { val result = try { count() } catch (e: ArithmeticException) { throw IllegalStateException(e) } // 使用 result } if 表达式 fun foo(param: Int) { val result = if (param == 1) { \"one\" } else if (param == 2) { \"two\" } else { \"three\" } } 返回类型为 Unit 的方法的 Builder 风格用法 fun arrayOfMinusOnes(size: Int): IntArray { return IntArray(size).apply { fill(-1) } } 单表达式函数 fun theAnswer() = 42 等价于 fun theAnswer(): Int { return 42 } 单表达式函数与其它惯用法一起使用能简化代码，例如和 when 表达式一起使用： fun transform(color: String): Int = when (color) { \"Red\" -> 0 \"Green\" -> 1 \"Blue\" -> 2 else -> throw IllegalArgumentException(\"Invalid color param value\") } 对一个对象实例调用多个方法 （with） class Turtle { fun penDown() fun penUp() fun turn(degrees: Double) fun forward(pixels: Double) } val myTurtle = Turtle() with(myTurtle) { // 画一个 100 像素的正方形 penDown() for (i in 1..4) { forward(100.0) turn(90.0) } penUp() } 配置对象的属性（apply） val myRectangle = Rectangle().apply { length = 4 breadth = 5 color = 0xFAFAFA } 这对于配置未出现在对象构造函数中的属性非常有用。 Java 7 的 try with resources val stream = Files.newInputStream(Paths.get(\"/some/file.txt\")) stream.buffered().reader().use { reader -> println(reader.readText()) } 对于需要泛型信息的泛型函数的适宜形式 // public final class Gson { // …… // public T fromJson(JsonElement json, Class classOfT) throws JsonSyntaxException { // …… inline fun Gson.fromJson(json: JsonElement): T = this.fromJson(json, T::class.java) 使用可空布尔 val b: Boolean? = …… if (b == true) { …… } else { // b 是 false 或者 null } 交换两个变量 var a = 1 var b = 2 a = b.also { b = a } TODO()：将代码标记为不完整 Kotlin 的标准库有一个 TODO() 函数，该函数总是抛出一个 NotImplementedError。 其返回类型为 Nothing，因此无论预期类型是什么都可以使用它。 还有一个接受原因参数的重载： fun calcTaxes(): BigDecimal = TODO(\"Waiting for feedback from accounting\") IntelliJ IDEA 的 kotlin 插件理解 TODO() 的语言，并且会自动在 TODO 工具窗口中添加代码指示。 "},"kotlin/coding_standards.html":{"url":"kotlin/coding_standards.html","title":"编码规范","keywords":"","body":"编码规范 本页包含当前 Kotlin 语言的编码风格。 源代码组织 目录结构 在纯 Kotlin 项目中，推荐的目录结构遵循省略了公共根包的包结构。例如，如果项目中的所有代码都位于 org.example.kotlin 包及其子包中，那么org.example.kotlin 包的文件应该直接放在源代码根目录下，而 org.example.kotlin.network.socket 中的文件应该放在源代码根目录下的 network/socket 子目录中。 对于 JVM 平台：Kotlin 源文件应当与 Java 源文件位于同一源文件根目录下， 并遵循相同的目录结构（每个文件应存储在与其 package 语句对应的目录中。 源文件名称 如果 Kotlin 文件包含单个类（以及可能相关的顶层声明），那么文件名应该与该类的名称相同，并追加 .kt 扩展名。如果文件包含多个类或只包含顶层声明， 那么选择一个描述该文件所包含内容的名称，并以此命名该文件。 使用首字母大写的驼峰风格（也称为 Pascal 风格）， 例如 ProcessDeclarations.kt。 文件的名称应该描述文件中代码的作用。因此，应避免在文件名中使用诸如“Util”之类的无意义词语。 源文件组织 鼓励多个声明（类、顶级函数或者属性）放在同一个 Kotlin 源文件中， 只要这些声明在语义上彼此紧密关联并且文件保持合理大小 （不超过几百行）。 特别是在为类定义与类的所有客户都相关的扩展函数时， 请将它们放在与类自身定义相同的地方。而在定义仅对指定客户有意义的扩展函数时，请将它们放在紧挨该客户代码之后。不要只是为了保存 “Foo 的所有扩展函数”而创建文件。 类布局 通常，一个类的内容按以下顺序排列： 属性声明与初始化块 次构造函数 方法声明 伴生对象 不要按字母顺序或者可见性对方法声明排序，也不要将常规方法与扩展方法分开。而是要把相关的东西放在一起，这样从上到下阅读类的人就能够跟进所发生事情的逻辑。选择一个顺序（高级别优先，或者相反）并坚持下去。 将嵌套类放在紧挨使用这些类的代码之后。如果打算在外部使用嵌套类，而且类中并没有引用这些类，那么把它们放到末尾，在伴生对象之后。 接口实现布局 在实现一个接口时，实现成员的顺序应该与该接口的成员顺序相同（如果需要， 还要插入用于实现的额外的私有方法） 重载布局 在类中总是将重载放在一起。 命名规则 在 Kotlin 中，包名与类名的命名规则非常简单： 包的名称总是小写且不使用下划线（org.example.project）。 通常不鼓励使用多个词的名称，但是如果确实需要使用多个词，可以将它们连接在一起或使用驼峰风格（org.example.myProject）。 类与对象的名称以大写字母开头并使用驼峰风格： open class DeclarationProcessor { /*……*/ } object EmptyDeclarationProcessor : DeclarationProcessor() { /*……*/ } 函数名 函数、属性与局部变量的名称以小写字母开头、使用驼峰风格而不使用下划线： fun processDeclarations() { /*……*/ } var declarationCount = 1 例外：用于创建类实例的工厂函数可以与抽象返回类型具有相同的名称： interface Foo { /*……*/ } class FooImpl : Foo { /*……*/ } fun Foo(): Foo { return FooImpl() } 测试方法的名称 当且仅当在测试中，可以使用反引号括起来的带空格的方法名。 （请注意，Android 运行时目前不支持这样的方法名。）测试代码中也允许方法名使用下划线。 class MyTestCase { @Test fun `ensure everything works`() { /*...*/ } @Test fun ensureEverythingWorks_onAndroid() { /*...*/ } } 属性名 常量名称（标有 const 的属性，或者保存不可变数据的没有自定义 get 函数的顶层/对象 val 属性）应该使用大写、下划线分隔的名称 (screaming snake case) names: const val MAX_COUNT = 8 val USER_NAME_FIELD = \"UserName\" 保存带有行为的对象或者可变数据的顶层/对象属性的名称应该使用驼峰风格名称： val mutableCollection: MutableSet = HashSet() 保存单例对象引用的属性的名称可以使用与 object 声明相同的命名风格： val PersonComparator: Comparator = /*...*/ 对于枚举常量，可以使用大写、下划线分隔的名称 (screaming snake case) （enum class Color { RED, GREEN }）也可使用首字母大写的常规驼峰名称，具体取决于用途。 幕后属性的名称 如果一个类有两个概念上相同的属性，一个是公共 API 的一部分，另一个是实现细节，那么使用下划线作为私有属性名称的前缀： class C { private val _elementList = mutableListOf() val elementList: List get() = _elementList } 选择好名称 类的名称通常是用来解释类是什么的名词或者名词短语：List、 PersonReader。 方法的名称通常是动词或动词短语，说明该方法做什么：close、 readPersons。 修改对象或者返回一个新对象的名称也应遵循建议。例如 sort 是对一个集合就地排序，而 sorted 是返回一个排序后的集合副本。 名称应该表明实体的目的是什么，所以最好避免在名称中使用无意义的单词 （Manager、 Wrapper 等）。 当使用首字母缩写作为名称的一部分时，如果缩写由两个字母组成，就将其大写（IOStream）； 而如果缩写更长一些，就只大写其首字母（XmlFormatter、 HttpInputStream）。 格式化 使用 4 个空格缩进。不要使用 tab。 对于花括号，将左花括号放在结构起始处的行尾，而将右花括号放在与左括结构横向对齐的单独一行。 if (elements != null) { for (element in elements) { // …… } } 在 Kotlin 中，分号是可选的，因此换行很重要。语言设计采用 Java 风格的花括号格式，如果尝试使用不同的格式化风格，那么可能会遇到意外的行为。 横向空白 在二元操作符左右留空格（a + b）。例外：不要在 “range to” 操作符（0..i）左右留空格。 不要在一元运算符左右留空格（a++） 在控制流关键字（if、 when、 for 以及 while）与相应的左括号之间留空格。 不要在主构造函数声明、方法声明或者方法调用的左括号之前留空格。 class A(val x: Int) fun foo(x: Int) { …… } fun bar() { foo(1) } 绝不在 (、 [ 之后或者 ]、 ) 之前留空格。 绝不在. 或者 ?. 左右留空格：foo.bar().filter { it > 2 }.joinToString(), foo?.bar() 在 // 之后留一个空格：// 这是一条注释 不要在用于指定类型参数的尖括号前后留空格：class Map { …… } 不要在 :: 前后留空格：Foo::class、 String::length 不要在用于标记可空类型的 ? 前留空格：String? 作为一般规则，避免任何类型的水平对齐。将标识符重命名为不同长度的名称不应该影响声明或者任何用法的格式。 冒号 在以下场景中的 : 之前留一个空格： 当它用于分隔类型与超类型时； 当委托给一个超类的构造函数或者同一类的另一个构造函数时； 在 object 关键字之后。 而当分隔声明与其类型时，不要在 : 之前留空格。 在 : 之后总要留一个空格。 abstract class Foo : IFoo { abstract fun foo(a: Int): T } class FooImpl : Foo() { constructor(x: String) : this(x) { /*……*/ } val x = object : IFoo { /*……*/ } } 类头格式化 具有少数主构造函数参数的类可以写成一行： class Person(id: Int, name: String) 具有较长类头的类应该格式化，以使每个主构造函数参数都在带有缩进的独立的行中。 另外，右括号应该位于一个新行上。如果使用了继承，那么超类的构造函数调用或者所实现接口的列表应该与右括号位于同一行： class Person( id: Int, name: String, surname: String ) : Human(id, name) { /*……*/ } 对于多个接口，应该将超类构造函数调用放在首位，然后将每个接口应放在不同的行中： class Person( id: Int, name: String, surname: String ) : Human(id, name), KotlinMaker { /*……*/ } 对于具有很长超类型列表的类，在冒号后面换行，并横向对齐所有超类型名： class MyFavouriteVeryLongClassHolder : MyLongHolder(), SomeOtherInterface, AndAnotherOne { fun foo() { /*...*/ } } 为了将类头与类体分隔清楚，当类头很长时，可以在类头后放一空行 （如上例所示）或者将左花括号放在独立行上： class MyFavouriteVeryLongClassHolder : MyLongHolder(), SomeOtherInterface, AndAnotherOne { fun foo() { /*...*/ } } 构造函数参数使用常规缩进（4 个空格）。 理由：这确保了在主构造函数中声明的属性与 在类体中声明的属性具有相同的缩进。 修饰符 如果一个声明有多个修饰符，请始终按照以下顺序安放： public / protected / private / internal expect / actual final / open / abstract / sealed / const external override lateinit tailrec vararg suspend inner enum / annotation / fun // 在 `fun interface` 中是修饰符 companion inline infix operator data 将所有注解放在修饰符前： @Named(\"Foo\") private val foo: Foo 除非你在编写库，否则请省略多余的修饰符（例如 public）。 注解格式化 注解通常放在单独的行上，在它们所依附的声明之前，并使用相同的缩进： @Target(AnnotationTarget.PROPERTY) annotation class JsonExclude 无参数的注解可以放在同一行： @JsonExclude @JvmField var x: String 无参数的单个注解可以与相应的声明放在同一行： @Test fun foo() { /*……*/ } 文件注解 文件注解位于文件注释（如果有的话）之后、package 语句之前，并且用一个空白行与 package 分开（为了强调其针对文件而不是包）。 /** 授权许可、版权以及任何其他内容 */ @file:JvmName(\"FooBar\") package foo.bar 函数格式化 如果函数签名不适合单行，请使用以下语法： fun longMethodName( argument: ArgumentType = defaultValue, argument2: AnotherArgumentType, ): ReturnType { // 函数体 } 函数参数使用常规缩进（4 个空格）。 理由：与构造函数参数一致 对于由单个表达式构成的函数体，优先使用表达式形式。 fun foo(): Int { // 不良 return 1 } fun foo() = 1 // 良好 表达式函数体格式化 如果函数的表达式函数体与函数声明不适合放在同一行，那么将 = 留在第一， 并将表达式函数体缩进 4 个空格。 fun f(x: String, y: String, z: String) = veryLongFunctionCallWithManyWords(andLongParametersToo(), x, y, z) 属性格式化 对于非常简单的只读属性，请考虑单行格式： val isEmpty: Boolean get() = size == 0 对于更复杂的属性，总是将 get 与 set 关键字放在不同的行上： val foo: String get() { /*……*/ } 对于具有初始化器的属性，如果初始化器很长，那么在等号后增加一个换行并将初始化器缩进四个空格： private val defaultCharset: Charset? = EncodingRegistry.getInstance().getDefaultCharsetForPropertiesFiles(file) 格式化控制流语句 如果 if 或 when 语句的条件有多行，那么在语句体外边总是使用大括号。 将该条件的每个后续行相对于条件语句起始处缩进 4 个空格。 将该条件的右圆括号与左花括号放在单独一行： if (!component.isSyncing && !hasAnyKotlinRuntimeInScope(module) ) { return createKotlinNotConfiguredPanel(module) } 理由：对齐整齐并且将条件与语句体分隔清楚 将 else、 catch、 finally 关键字以及 do/while 循环的 while 关键字与之前的花括号放在相同的行上： if (condition) { // 主体 } else { // else 部分 } try { // 主体 } finally { // 清理 } 在 when 语句中，如果一个分支不止一行，可以考虑用空行将其与相邻的分支块分开： private fun parsePropertyValue(propName: String, token: Token) { when (token) { is Token.ValueToken -> callback.visitValue(propName, token.value) Token.LBRACE -> { // …… } } } 将短分支放在与条件相同的行上，无需花括号。 when (foo) { true -> bar() // 良好 false -> { baz() } // 不良 } 方法调用格式化 在较长参数列表的左括号后添加一个换行符。按 4 个空格缩进参数。 将密切相关的多个参数分在同一行。 drawSquare( x = 10, y = 10, width = 100, height = 100, fill = true ) 在分隔参数名与值的 = 左右留空格。 链式调用换行 当对链式调用换行时，将 . 字符或者 ?. 操作符放在下一行，并带有单倍缩进： val anchor = owner ?.firstChild!! .siblings(forward = true) .dropWhile { it is PsiComment || it is PsiWhiteSpace } 调用链的第一个调用通常在换行之前，当然如果能让代码更有意义也可以忽略这点。 Lambda 表达式格式化 在 lambda 表达式中，应该在花括号左右以及分隔参数与代码体的箭头左右留空格。 如果一个调用接受单个 lambda 表达式，应该尽可能将其放在圆括号外边传入。 list.filter { it > 10 } 如果为 lambda 表达式分配一个标签，那么不要在该标签与左花括号之间留空格： fun foo() { ints.forEach lit@{ // …… } } 在多行的 lambda 表达式中声明参数名时，将参数名放在第一行，后跟箭头与换行符： appendCommaSeparated(properties) { prop -> val propertyValue = prop.get(obj) // …… } 如果参数列表太长而无法放在一行上，请将箭头放在单独一行： foo { context: Context, environment: Env -> context.configureEnv(environment) } 尾随逗号 尾随逗号是一系列元素的最后一项之后的逗号符号： class Person( val firstName: String, val lastName: String, val age: Int, // trailing comma ) 使用尾随逗号有几个好处： 它使版本控制差异更清晰——因为所有的焦点都集中在改变的值上。 它使添加和重新排序元素变得容易——如果您操作元素，则无需添加或删除逗号。 它简化了代码生成，例如，对象初始值设定项。最后一个元素也可以有逗号。 尾随逗号完全是可选的——没有它们你的代码仍然可以工作。 Kotlin 风格指南鼓励在声明站点使用尾随逗号，并将其留给调用站点由您自行决定。 要在 IntelliJ IDEA 格式化程序中启用尾随逗号，请转到设置 |编辑 |代码风格 | Kotlin，打开其他选项卡并选择使用尾随逗号选项。 Kotlin 在以下情况下支持尾随逗号： 枚举 值参数 类属性和参数 函数值参数 可选类型的参数（包括 setter） 索引后缀 Lambda 参数 when 入口 集合文字（在注释中） 类型参数（Type arguments） 类型参数（Type parameters） 解构声明 文档注释 避免重复结构 语言特性的惯用法 库的编码规范 "},"linux/linux.html":{"url":"linux/linux.html","title":"Linux常用命令","keywords":"","body":"常用 Linux 命令 切换用户 su 是最简单的用户切换命令，通过该命令可以实现任何身份的切换，包括从普通用户切换为 root 用户、从 root 用户切换为普通用户以及普通用户之间的切换。 普通用户之间切换以及普通用户切换至 root 用户，都需要知晓对方的密码，只有正确输入密码，才能实现切换；从 root 用户切换至其他用户，无需知晓对方密码，直接可切换成功。 su 命令的基本格式如下： [root@localhost ~]# su [选项] 用户名 选项： -：当前用户不仅切换为指定用户的身份，同时所用的工作环境也切换为此用户的环境（包括 PATH 变量、MAIL 变量等），使用 - 选项可省略用户名，默认会切换为 root 用户。 -l：同 - 的使用类似，也就是在切换用户身份的同时，完整切换工作环境，但后面需要添加欲切换的使用者账号。 -p：表示切换为指定用户的身份，但不改变当前的工作环境（不使用切换用户的配置文件）。 -m：和 -p 一样； -c命令：仅切换用户执行一次命令，执行后自动切换回来，该选项后通常会带有要执行的命令。 # 选项： -m, -p, --preserve-environment 不重置环境变量 -g, --group 指定主组 -G, --supp-group 指定一个辅助组 -, -l, --login 使 shell 成为登录 shell -c, --command 使用 -c 向 shell 传递一条命令 --session-command 使用 -c 向 shell 传递一条命令而不创建新会话 -f, --fast 向shell 传递 -f 选项(csh 或 tcsh) -s, --shell 若 /etc/shells 允许，则运行 shell -h, --help 显示此帮助并退出 -V, --version 输出版本信息并退出 示例1： [lamp@localhost ~]$ su - root 密码： 输入 root 用户的密码 #\"-\"代表连带环境变量一起切换，不能省略 示例2： [lamp@localhost ~]$ whoami lamp #当前我是lamp [lamp@localhost ~]$ su - -c \"useradd user1\" root 密码： #不切换成root，但是执行useradd命令添加user1用户 [lamp@localhost ~]$ whoami lamp #我还是lamp [lamp@localhost ~]$ grep \"user1' /etc/passwd userl:x:502:504::/home/user1:/bin/bash #user用户已经添加了 除了像例 2 这样，执行一条命令后用户身份会随即自动切换回来，其他切换用户的方式不会自动切换，只能使用 exit 命令进行手动切换，例如： [lamp@localhost ~]$ whoami lamp #当前我是lamp [lamp@localhost ~]$ su - lamp1 Password: su 和 su - 的区别 注意，使用 su 命令时，有 - 和没有 - 是完全不同的，- 选项表示在切换用户身份的同时，连当前使用的环境变量也切换成指定用户的。我们知道，环境变量是用来定义操作系统环境的，因此如果系统环境没有随用户身份切换，很多命令无法正确执行。 举个例子，普通用户 lamp 通过 su 命令切换成 root 用户，但没有使用 - 选项，这样情况下，虽然看似是 root 用户，但系统中的 $PATH 环境变量依然是 lamp 的（而不是 root 的），因此当前工作环境中，并不包含 /sbin、/usr/sbin等超级用户命令的保存路径，这就导致很多管理员命令根本无法使用。不仅如此，当 root 用户接受邮件时，会发现收到的是 lamp 用户的邮件，因为环境变量 $MAIL 也没有切换。 初学者可以这样理解它们之间的区别，即有 - 选项，切换用户身份更彻底；反之，只切换了一部分，这会导致某些命令运行出现问题或错误（例如无法使用 service 命令）。 通过下面这个例子，可直观的看到 su 和 su - 的区别： [lamp@localhost ~]$ whoami lamp #查询用户身份，我是lamp [lamp@localhost ~]$ su root 密码: 可以看到，在不使用 su - 的情况下，虽然用户身份成功切换，但环境变量依旧用的是原用户的，切换并不完整。 查看防火墙及开放端口 查看 Linux 系统版本的命令 1. 查看Linux内核版本命令（两种方法） cat /proc/version uname -a 2. 查看Linux系统版本的命令（3种方法） lsb_release -a 即可列出所有版本信息，这个命令适用于所有的 Linux 发行版，包括 RedHat、SUSE、Debian…等发行版。 cat /etc/redhat-release 这种方法只适合 Redhat 系的 Linux。 cat /etc/issue 此命令也适用于所有的 Linux 发行版。 iptables防火墙（CentOS 6） 1、service 方式 1）查看防火墙状态： [root@centos6 ~]# service iptables status 2）开启防火墙： [root@centos6 ~]# service iptables start 3）关闭防火墙： [root@centos6 ~]# service iptables stop 4）重启防火墙： [root@centos6 ~]# service iptables restart 5）永久关闭防火墙： [root@centos6 ~]# chkconfig iptables off 6）永久关闭后重启： [root@centos6 ~]# chkconfig iptables on 2、iptables 方式 1）先进入 init.d 目录，命令如下： [root@centos6 ~]# cd /etc/init.d/ 2）查看防火墙状态： [root@centos6 init.d]# /etc/init.d/iptables status 3）暂时关闭防火墙： [root@centos6 init.d]# /etc/init.d/iptables stop 4）重启防火墙： [root@centos6 init.d]# /etc/init.d/iptables restart firewalld 防火墙（CentOS 7） 1、查看 firewalld 服务状态 systemctl status firewalld 出现 Active: active (running) 高亮显示则表示是启动状态。 出现 Active: inactive (dead) 灰色表示停止，看单词也行。 2、查看 firewalld 的状态 firewall-cmd --state 3、开启、重启、关闭firewalld.service服务 1）开启 service firewalld start 2）重启 service firewalld restart 3）关闭 service firewalld stop 4、查看防火墙规则 firewall-cmd --list-all 5、查询、开放、关闭端口 1）查询端口是否开放 firewall-cmd --query-port=8080/tcp 2）开放80端口 firewall-cmd --permanent --add-port=80/tcp 3）移除端口 firewall-cmd --permanent --remove-port=8080/tcp 4）重启防火墙(修改配置后要重启防火墙) firewall-cmd --reload 6、参数解释 1）firwall-cmd：是 Linux 提供的操作 firewall 的一个工具； 2）--permanent：表示设置为持久； 3）--add-port：标识添加的端口； 查看端口占用 Linux 查看端口占用情况的方法： 1、使用 lsof 命令，语法格式 lsof -i:端口号；2、使用 netstat 命令，该命令可以显示 tcp、udp 的端口和进程等相关情况，语法格式 netstat -tunlp | grep 端口号。 lsof lsof(list open files) 是一个列出当前系统打开文件的工具。 lsof 查看端口占用语法格式： lsof -i:端口号 实例 查看服务器 8000 端口的占用情况： # lsof -i:8000 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME nodejs 26993 root 10u IPv4 37999514 0t0 TCP *:8000 (LISTEN) 可以看到 8000 端口已经被轻 nodejs 服务占用。 lsof -i 需要 root 用户的权限来执行，如下图： 更多 lsof 的命令如下： lsof -i:8080 查看8080端口占用 lsof abc.txt 显示开启文件abc.txt的进程 lsof -c abc 显示abc进程现在打开的文件 lsof -c -p 1234 列出进程号为1234的进程所打开的文件 lsof -g gid 显示归属 gid 的进程情况 lsof +d /usr/local/ 显示目录下被进程开启的文件 lsof +D /usr/local/ 同上, 但是会搜索目录下的目录, 时间较长 lsof -d 4 显示使用 fd 为4的进程 lsof -i -U 显示所有打开的端口和 UNIX domain 文件 netstat netstat -tunlp 用于显示 tcp，udp 的端口和进程等相关情况。 netstat 查看端口占用语法格式： netstat -tunlp | grep 端口号 -t (tcp) 仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化为数字 -l 仅列出在Listen(监听)的服务状态 -p 显示建立相关链接的程序名 例如查看 8000 端口的情况，使用以下命令： # netstat -tunlp | grep 8000 tcp 0 0 0.0.0.0:8000 0.0.0.0:* LISTEN 26993/nodejs 更多命令： netstat -ntlp // 查看当前所有tcp端口 netstat -ntulp | grep 80 // 查看所有80端口使用情况 netstat -ntulp | grep 3306 // 查看所有3306端口使用情况 fuser 使用 fuser 命令可以直接在 Linux 上查看端口被哪个进程占用了。 fuser 80/tcp 上面的命令查看 80 端口被哪个进程占用了。你可能会看到类似下面的结果： 如果想看到详情可以加上 -v 开关，运行结果里会包含进程的名字： fuser -v 80/tcp 如果要杀掉进程可以使用 -k 开关： fuser -k 80/tcp 查看内存占用 # -m 以MB为单位的方式显示 free -m 查看剩余空间 df -Th 参数说明： -a或--all：包含全部的文件系统； --block-size=：以指定的区块大小来显示区块数目； -h或--human-readable：以可读性较高的方式来显示信息； -H或--si：与-h参数相同，但在计算时是以1000 Bytes为换算单位而非1024 Bytes； -i或--inodes：显示inode的信息； -k或--kilobytes：指定区块大小为1024字节； -l或--local：仅显示本地端的文件系统； -m或--megabytes：指定区块大小为1048576字节； --no-sync：在取得磁盘使用信息前，不要执行sync指令，此为预设值； -P或--portability：使用POSIX的输出格式； --sync：在取得磁盘使用信息前，先执行sync指令； -t或--type=：仅显示指定文件系统类型的磁盘信息； -T或--print-type：显示文件系统的类型； -x或--exclude-type=：不要显示指定文件系统类型的磁盘信息； --help：显示帮助； --version：显示版本信息。 查看文件和目录大小的命令 du -sh 文件/目录名 参数说明： -a或-all 显示目录中个别文件的大小。 -b或-bytes 显示目录或文件大小时，以byte为单位。 -c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。 -k或--kilobytes 以KB(1024bytes)为单位输出。 -m或--megabytes 以MB为单位输出。 -s或--summarize 仅显示总计，只列出最后加总的值。 -h或--human-readable 以K，M，G为单位，提高信息的可读性。 -x或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。 -L或--dereference 显示选项中所指定符号链接的源文件大小。 -S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。 -X或--exclude-from= 在指定目录或文件。 --exclude= 略过指定的目录或文件。 -D或--dereference-args 显示指定符号链接的源文件大小。 -H或--si 与-h参数相同，但是K，M，G是以1000为换算单位。 -l或--count-links 重复计算硬件链接的文件。 排序命令 sort命令可以用于将文件内容排序并输出，也可以用于将某些查询命令的执行结果排序后输出，比如要将文件夹中的文件按大小排序，可以用以下命令： du -a|sort -rn 管道前面的du –a就是列出目录下所有的文件和目录的大小，后面的sort命令就是排序。 其中-r参数代表反向排序，因为sort默认是从小到大排序的，加-r是从大到小排序 -n代表按照数字排序，只认数字不认单位，本例中的数字就是文件大小，单位是默认的KB，所以这个命令不能用du -ah，这会使排序结果出现2M小于100K的情况。 -b：忽略每行前面开始出的空格字符； -c：检查文件是否已经按照顺序排序； -d：排序时，处理英文字母、数字及空格字符外，忽略其他的字符； -f：排序时，将小写字母视为大写字母； -i：排序时，除了040至176之间的ASCII字符外，忽略其他的字符； -m：将几个排序号的文件进行合并； -M：将前面3个字母依照月份的缩写进行排序； -n：依照数值的大小排序； -o：将排序后的结果存入制定的文件； -r：以相反的顺序来排序； -t：指定排序时所用的栏位分隔字符； +-：以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。 由参数可见sort命令主要还是用于文件内容输出的 只显示前几行的命令 head命令可以用于显示文件的前几行，也可以用于显示某些查询命令结果的前几行 比如要将文件夹中的文件按大小排序，而且只看最大的几个，可以用以下命令： head后面的-5表示显示前5行，不加数字则默认显示前10行 du -a|sort -rn|head -5 参数说明： -n：指定显示头部内容的行数； -c：指定显示头部内容的字符数； -v：总是显示文件名的头信息； -q：不显示文件名的头信息。 "},"linux/command_abbreviation.html":{"url":"linux/command_abbreviation.html","title":"Linux常用命令英文解释","keywords":"","body":"Linux常用命令英文全称与中文解释 命令 全称 说明 man Manual 意思是手册，可以用这个命令查询其他命令的用法。 pwd Print working directory 意思是密码。 su Swith user 切换用户，切换到root用户 cd Change directory 切换目录 ls List files 列出目录下的文件 ps Process Status 进程状态 mkdir Make directory 建立目录 rmdir Remove directory 移动目录 mkfs Make file system 建立文件系统 fsck File system check 文件系统检查 cat Concatenate 串联 uname Unix name 系统名称 df Disk free 空余硬盘 du Disk usage 硬盘使用率 lsmod List modules 列表模块 mv Move file 移动文件 rm Remove file 删除文件 cp Copy file 复制文件 ln Link files 链接文件 fg Foreground 前景 bg Background 背景 chown Change owner 改变所有者 chgrp Change group 改变用户组 chmod Change mode 改变模式 umount Unmount 卸载 dd 本来应根据其功能描述“Convert an copy”命名为“cc”，但“cc”已经被用以代表“C Complier”，所以命名为“dd” tar Tape archive 解压文件 ldd List dynamic dependencies 列出动态相依 insmod Install module 安装模块 rmmod Remove module 删除模块 lsmod List module 列表模块 sudo superuser do 是superuser do的简写 reboot 重启 logout 退出 注销 binary 二进制 device 设备 手段 etcetera 等等 系统配置文件 recursion 递归（-R） disrecursion 不递归（-d） force 直接覆盖（-f） all 所有的（-a） list 列出所有信息（-l） if:提示是否覆盖（-I） 普通文件（-）：文本文件和二进制文件 目录文件（d）：文件夹 连接文件（l）:ln创建的文件 特殊文件：设备文件（b,c）和管道文件（p) 图形界面要注销就从菜单里选择或者快捷键ctrl+alt＋backspace 修改登录界面启动：vi /etc/inittab 3 文本 5 图像 使用 man或info 查看有关命令的帮助 使用fdisk -l 显示分区情形；df -h显示磁盘使用情形 使用du -sh /*查看某个(根目录所有文件夹)目录占有磁盘情形 查看linux版本号：uname -a 清屏：clear 检查修复文件系统（非正常关机）：fsck 查找文件：find /etc -name 文件名 （/etc为起始目录） 列出某个目录的详细信息：ls -l /etc(/etc为目录) 当前目录：cd . 上一层目录：cd .. 查看目录路径：pwd 创建目录：mkdir 1(1为文件名) 删除空目录：rmdir 1 删除不为空的目录或文件：rm -r（-f） 1 查看用户信息：vi /etc/passwd 隐式密码：vi /etc/shadow 查看某个文件的内容：cat /etc/inittab 移动文件：mv 1.c /root (移动1.c到root中) 创建文件：vi 1.c 复制文件到指定目录：cp /root/1.c/home/1.c(从root目录复制到home目录下) 比较两个文件：diff 1.c 2.c 或cmp 1.c 2.c 标准用户输入：cat （输入完后安ctrl d退出） 显示重定向：ls -l > ls.txt(显示到ls.txt上；0>输入重定向；1>输出重定向；2>错误重定向) 设置文件的读写权限：chmod u+w 1.c(增加文件拥有者对1.c写的权限) chmod g-r 1.c( 删除工作组对1.c读的权限) chmod o+x 1.c(增加其他用户对1.c的执行权限) chmod a-w 1.c(删除所有用户对1.c写的权限) 列出文件索引好：ls -i 构建软硬连接：in -s /home/lxt008 /008(将lxt008链接至008 即008是lxt008的快捷方式 若无-s就是硬链接) 查看DNS客户端配置：more /etc/resolv.conf 查看ip地址：ifconfig(看以上两者的ip是否相符，若不相符 使用下面的命令修改) 更改网络配置：netconfig（修改好后，要使用service network restart重启网络后方能生效） 查看默认路关：route -n 修改默认网关：route add default gw 192.168.88.1(ip和默认网关在同一网段方能联网) 或使用 ifconfig eth0 192.168.88.8 netmask 255.255.255.0 修改ip和子网掩码 结束进程：ctrl+ c(或D) 查看网络状况：netstat 查看某个rpm包是否安装：rpm -qi a.rpm 安装某个包：rpm -ivh a.rpm 打包：tar -cvf lxt008.tar /home/lxt008(将home目录下的路线图lxt008文件夹打包成lxt008.tar v是view简写 f为file) 解包：tar -xvf lxt008.tar /home(解压到home中) 查看包的内容：tar -tvf lxt008.tar 打包并压缩：tar -czvf 008.tar.gz /home/lxtoo8 解压包：tar -xzvf 008.tar.gz /home 注释掉：# 创建shell脚本：vi first.sh 显示字符串：echo \"王林\" 等待从终端输入给变量：read f(f为变量) 显示变量内容：echo ${f} 查看环境变量：env 不需要换行：-n 查看运行的进程：ps 杀掉某个线程：kill 1186（1186是线程号） 将某个进程设为后台运行：find / -name passwd &(将find / -name passwd进程设为后台运行) 管道：ls -l /dev | more (列出dev目录下的详细信息 又要分页) vi编辑器中保存文件：w +文件名 显示行号：：set nu "},"linux/vi.html":{"url":"linux/vi.html","title":"Linux vi命令","keywords":"","body":"1. Linux shell 命令行下删除一个单词的方法 CTRL + H：相当于按了一次退格键，一次删除一个字母。CTRL + U：一次删一行。CTRL + W：一次删一个单词，也可以这么理解，一次删一个空格的位置，比如:face book abcd edff，这种情况要按四次才能删完。 2 Linux vi 操作命令 2.1 vi 下删除一个单词的方法： D 从当前位置删除到行尾 (d$ 的缩写)db 从当前位置删除到前一个单词的开头dw 从当前位置删除到下一个单词开头x 删除当前光标下的字符 (dl 的缩写)X 删除当前光标前的字符 (dh 的缩写)dG 从当前行删除到文件末dgg 从当前行删除到文件首 dl 删除字符 (缩写: x)dnw 删除n个单词，其中n表示具体的数字dd 删除一行，删除后下面的行会移上来填补空缺 c 功能和 d 相同，区别在于完成删除操作后进入 INSERT MODEC 代表 c$(删除到行尾的内容)cc 也是删除当前行，然后进入 INSERT MODEc$ 删除当前光标到行尾的内容。s 代表 cl(删除一个字符)S 代表 cc(删除一整行) 2.2 在 vi 中移动光标 k 上h l 左 右j 下 ^ 移动到该行第一个非空格的字符处w 向前移动一个单词，将符号或标点当作单词处理W 向前移动一个单词，不把符号或标点当作单词处理b 向后移动一个单词，把符号或标点当作单词处理B 向后移动一个单词，不把符号或标点当作单词处理e 命令会将光标移动到下一个单词的最后一个字符。命令\"ge\"，它将光标移动到前一个单词的最后一个字符上。( 光标移至句首) 光标移至句尾{ 光标移至段落开头} 光标移至段落结尾H 光标移至屏幕顶行M 光标移至屏幕中间行L 光标移至屏幕最后行0 到行首$ 到行尾gg 到页首G 到页末行号+G 跳转到指定行（另一个移动到某行的方法是在命令\"%\"之前指定一个命令计数比如\"50%\"将会把光标定位在文件的中间. \"90%\"跳到接近文件尾的地方。 命令\"H\",\"M\",\"L\",分别将光标跳转到第一行，中间行，结尾行部分。）n+ 光标下移n行n- 光标上移n行Ctrl+g 查询当前行信息和当前文件信息fx 向右跳到本行字符 x 处（x 可以是任何字符）Fx 向左跳到本行字符 x 处（x 可以是任何字符） tx 和 fx 相同，区别是跳到字符 x 前Tx 和 Fx 相同，区别是跳到字符 x 后C-b 向上滚动一屏C-f 向下滚动一屏C-u 向上滚动半屏C-d 向下滚动半屏C-y 向上滚动一行C-e 向下滚动一行 nzz 将第 n 行滚至屏幕中间位置，不指定 n 时将当前行滚至屏幕中间位置。zz 命令会把当前行置为屏幕正中央，zt 命令会把当前行置于屏幕顶端，zb 则把当前行置于屏幕底端. 使用命令计数 假设你要向上移动9行。这可以用\"kkkkkkkkk\"或\"9k\"来完成。事实上，很多命令都可以接受一个数字作为重复执行同一命令的次数。比如刚才的例子，要在行尾追加三个感叹号，当时用的命令是\"a!!!\"。另一个办法是用\"3a!\"命令。3说明该命令将被重复执行3次。同样，删除3个字符可以用\"3x\"。指定的数字要紧挨在它所要修饰的命令前面。 2.3 进入和退出 vi 命令 vi filename 打开或新建文件，并将光标置于第一行首vi +n filename 打开文件，并将光标置于第 n 行首vi + filename 打开文件，并将光标置于最后一行首vi +/pattern filename 打开文件，并将光标置于第一个与 pattern 匹配的串处vi -r filename 在上次正用 vi 编辑时发生系统崩溃，恢复 filenamevi filename … filename 打开多个文件，依次进行编辑 ZZ 退出 vi 并保存:q! 退出 vi，不保存，用 :e! 命令放弃所有修改并重新载入该文件的原始内容。:wq 退出 vi 并保存 2.4 重复操作 . 重复上一次操作 2.5 自动补齐 C-n 匹配下一个关键字C-p 匹配上一个关键字 2.6 插入 o 在光标下方新开一行并将光标置于新行行首，进入插入模式。O 同上，在光标上方。 i 在光标之前进入插入模式。a 在光标之后进入插入模式。A 同上，在光标之前。 R 进入替换模式，直到按下 Escset xxx 设置 XXX 选项。 2.7 行合并 J 把下面一行合并到本行后面 2.8 vi 中查找及替换命令 /pattern 从光标开始处向文件尾搜索 pattern?pattern 从光标开始处向文件首搜索 patternn 在同一方向重复上一次搜索命令N 在反方向上重复上一次搜索命令% 查找配对的括号 如果查找内容忽略大小写，则用命令 set ignorecase, 返回精确匹配用命令 set noignorecase。 如果你用 /the 来查找Vim也会匹配到 there 。要查找作为独立单词的 the 使用如下命令： /the\\>。 \\> 是一个特殊的记法，它只匹配一个 word 的结束处。 要搜索整个单词，请键入 \\ 标记单词的开头，键入 \\> 标记单词的结尾： 例如，要搜索单词 foo，可以使用 \\： :s/\\/bar/ 替换字符串命令格式如下： [range]s/s1/s2/ [option] [range] 表示检索范围，省略时表示当前行。下面是一些检索范围的例子。 1,10 表示从第 1 行到 10 行。 % 表示整个文件，同 1,$。 .,$ 从当前行到文件尾。 s 为替换命令。 s1 要被替换的串，s2 为替换的串。 option 表示选项： /g 表示在全局文件中进行替换。 /c 表示在每次替换之前需要用户进行确认。 省略时仅对每行第一个匹配串进行替换。 :s/p1/p2/g 将当前行中所有 p1 均用 p2 替代，若要每个替换都向用户询问则应该用 gc 选项，其中，s 表示替换，g 表示全部替换，如果只替换第一个，把 /g 去掉即可。:n1,n2s/p1/p2/g 将第 n1 至 n2 行中所有 p1 均用 p2 替代，如果 n1 为 . 表示从当前行开始，最后一行可以用 $ 表示。:g/p1/s//p2/g 将文件中所有 p1 均用 p2 替换 .*[]^%~$ 在vi中具有特殊含义，若需要查找则应该加上转义字符\"\" 替代历史 要浏览历史记录以查找先前的替代命令，请输入 :s 并使用向上或向下箭头键查找先前的替代操作。 要运行该命令，只需按 Enter。 您也可以在执行操作之前编辑命令。 例子 注释行（在行前添加＃）从5到20： :5,20s/^/#/ 取消注释行从5到20，恢复以前的更改： :5,20s/^#// 将“苹果”，“橙色”和“芒果”的所有实例替换为“水果”： :%s/apple\\|orange\\|mango/fruit/g 删除每行末尾的空格： :%s/\\s\\+$//e 匹配一行的开头与结尾 ^ 字符匹配一行的开头。$ 字符匹配一行的末尾。 所以 /was$ 只匹配位于一行末尾的单词 was，所以 /^was 只匹配位于一行开始的单词was。 匹配任何的单字符 .这个字符可以匹配到任何字符。比如 c.m 可以匹配任何前一个字符是 c，后一个字符是 m 的情况，不管中间的字符是什么。 匹配特殊字符 放一个反斜杠在特殊字符前面。如果你查找 ter。，用命令 /ter\\。 使用标记 当你用 G 命令从一个地方跳转到另一个地方时，vim 会记得你起跳的位置。这个位置在 vim 中是一个标记。使用命令 `` 可以使你跳回到刚才的出发点。 `` 命令可以在两点之间来回跳转。CTRL-O 命令是跳转到你更早些时间停置光标的位置(提示:O 意为 older). CTRL-I 则是跳回到后来停置光标的更新的位置(提示：I 在键盘上位于 O 前面)。 注:使用CTRL-I 与按下键一样。 2.9 设置高亮 :set hlsearch 设置高亮:set nohlsearch 关闭高亮:nohlsearch 关闭当前已经设置的高亮 2.10 增量查找 :set incsearch 设置增量查找:set noincsearch 关闭增量查找 2.11 更改字符 rx 将当前光标下的字符更改为 x（x 为任意字符） 例如：更改当前光标下的字符的大小写 2.12 恢复误操作 u 撤销最后执行的命令U 修正之前对该行的操作Ctrl + R Redo 2.13 在Vi中操作 Frame c-w c-n 增加 framec-w c-c 减少 framec-w c-w 切换 framec-w c-r 交换两个 frame VIM中的块操作 Vim支持多达26个剪贴板 选块 先用v，C-v，V选择一块，然后用y复制，再用p粘贴。 yy 复制当前整行nyy 复制当前行开始的n行内容?nyy 将光标当前行及其下n行的内容保存到寄存器?中，其中?为一个字母，n为一个数字?nyw 将光标当前行及其下n个词保存到寄存器?中，其中?为一个字母，n为一个数字?nyl 将光标当前行及其下n个字符保存到寄存器?中，其中?为一个字母，n为一个数字?p 将寄存器?中的内容粘贴到光标位置之后。如果?是用yy复制的完整行，则粘贴在光标所在行下面。这里?可以是一个字母，也可以是一个数字?P 将寄存器a中的内容粘贴到光标位置之前。如果?是用yy复制的完整行，则粘贴在光标所在行上面。这里?可以是一个字母，也可以是一个数字 y操作符命令会把文本复制到一个寄存器3中。然后可以用p命令把它取回。因为y是一个操作符命令，所以你可以用yw来复制一个word. 同样可以使用命令记数。如下例中用y2w命令复制两个word，yy命令复制一整行，Y也是复制整行的内容，复制当前光标至行尾的命令是y$。 ay[motion] ay$ 复制光标位置到行末并保存在寄存器a中 ayft 复制光标位置到当前行第一个字母 t 并保存在寄存器 a 中 以上指令皆可去掉 a 工作，则 y,p 对未命名寄存器工作（所有d,c,x,y的对象都被保存在这里）。 以d或x这样的命令删除文本时，被删除的内容还是被保存了起来。你还可以用 p 命令把它取回来。P命令是把被去回的内容放在光标之前，p则是放在光标之后。对于以dd删除的整行内容， P会把它置于当前行的上一行。p则是至于当前行的后一行。也可以对命令p和P命令使用命令记数。它的效果是同样的内容被取回指定的次数。这样一来dd之后的3p就可以把被删除行的3份副本放到当前位置。 命令 xp 将光标所在的字符与后一个字符交换。 vi的选项设置 all 列出所有选项设置情况term 设置终端类型ignorance 在搜索中忽略大小写list 显示制表位(Ctrl+I)和行尾标志($)number 显示行号report 显示由面向行的命令修改过的数目terse 显示简短的警告信息warn 在转到别的文件时若没保存当前文件则显示NO write信息nomagic 允许在搜索模式中，使用前面不带\"\\\"的特殊字符nowrapscan 禁止vi在搜索到达文件两端时，又从另一端开始mesg 允许vi显示其他用户用write写到自己终端上的信息 2.14 查看文件 仅是查看文件，不向文件写入内容，可以用只读形式编辑文件。用命令： vim -R file 如果是想强制性地避免对文件进行修改，可以用命令： vim -M file 2.15 更改文件名 将现有文件存成新的文件，用命令:sav(eas) move.c。如果想改变当前正在编辑的文件名，但不想保存该文件，就可以用命令：:f(ile) move.c。 2.16 分割一个窗口 打开一个新窗口最简单的办法就是使用命令：:split。CTRL-W 命令可以切换当前活动窗口。 2.17 关闭窗口 用命令：:close.可以关闭当前窗口。实际上,任何退出文件编辑的命令:quit和ZZ都会关闭窗口，但是用:close可以阻止你关闭最后一个 Vim，以免以意外地整个关闭了 Vim。 2.18 关闭除当前窗口外的所有其他窗口 用命令：:only,关闭除当前窗口外的所有其它窗口。如果这些窗口中有被修改过的，你会得到一个错误信息，同时那个窗口会被留下来。 2.19 为另一个文件分隔出一个窗口 命令:split two.c可以打开第二个窗口同时在新打开的窗口中开始编辑作为 参数的文件。如果要打开一个新窗口并开始编辑一个空的缓冲区，使用命令::new。 2.20 垂直分割 用命令:vsplit 或：:vsplit two.c。同样有一个对应的 :vnew 命令，用于垂直分隔窗口并在其中打开一个新的空缓冲区。 2.21 切换窗口 CTRL-W h 到左边的窗口 CTRL-W j 到下面的窗口 CTRL-W k 到上面的窗口 CTRL-W l 到右边的窗口 CTRL-W t 到顶部窗口 CTRL-W b 到底部窗口 2.22 针对所有窗口操作的命令 :qall放弃所有操作并退出，:wall保存所有，:wqall保存所有并退出。 2.23 为每一个文件打开一个窗口 使用-o选项可以让 Vim 为每一个文件打开一个窗口： vim -o one.txt two.txt three.txt。 2.24 使用 vimdiff 查看不同 vimdiff main.c~ main.c,另一种进入 diff 模式的办法可以在 Vim 运行中操作。编辑文件main.c，然后打开另一个分隔窗口显示其不同: :edit main.c :vertical diffpatch main.c.diff。 2.25 页签 命令:tabe(dit) thatfile在一个窗口中打开thatfile，该窗口占据着整个的 Vim 显示区域。命令:tab split/new结果是新建了一个拥有一个窗口的页签。以用 gt 命令在不同的页签间切换。 "},"sql/sql.html":{"url":"sql/sql.html","title":"SQL语法","keywords":"","body":"1. 基本概念 1.1 数据库术语 数据库（database） - 保存有组织的数据的容器（通常是一个文件或一组文件）。 数据表（table） - 某种特定类型数据的结构化清单。 模式（schema） - 关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。 列（column） - 表中的一个字段。所有表都是由一个或多个列组成的。 行（row） - 表中的一个记录。 主键（primary key） - 一列（或一组列），其值能够唯一标识表中每一行。 1.2 SQL 语法 SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。 1.2.1 SQL 语法结构 SQL 语法结构包括： 子句 - 是语句和查询的组成成分。（在某些情况下，这些都是可选的。） 表达式 - 可以产生任何标量值，或由列和行的数据库表 谓词 - 给需要评估的 SQL 三值逻辑（3VL）（true/false/unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。 查询 - 基于特定条件检索数据。这是 SQL 的一个重要组成部分。 语句 - 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。 1.2.2 SQL 语法要点 SQL 语句不区分大小写，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。 例如：SELECT 与 select、Select 是相同的。 多条 SQL 语句必须以分号（;）分隔。 处理 SQL 语句时，所有空格都被忽略。SQL 语句可以写成一行，也可以分写为多行。 ## 一行 SQL 语句 UPDATE user SET username='robot', password='robot' WHERE username = 'root'; ## 多行 SQL 语句 UPDATE user SET username='robot', password='robot' WHERE username = 'root'; SQL 支持三种注释## 注释1 -- 注释2 /* 注释3 */ 1.3 SQL 分类 1.3.1 数据定义语言（DDL） 数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。 DDL 的主要功能是定义数据库对象。 DDL 的核心指令是 CREATE、ALTER、DROP。 1.3.2 数据操纵语言（DML） 数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。 DML 的主要功能是访问数据，因此其语法都是以读写数据库为主。 DML 的核心指令是 INSERT、UPDATE、DELETE、SELECT。这四个指令合称 CRUD(Create, Read, Update, Delete)，即增删改查。 1.3.3 事务控制语言（TCL） 事务控制语言 (Transaction Control Language, TCL) 用于管理数据库中的事务。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。 TCL 的核心指令是 COMMIT、ROLLBACK。 1.3.4 数据控制语言（DCL） 数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。 DCL 的核心指令是 GRANT、REVOKE。 DCL 以控制用户的访问权限为主，因此其指令作法并不复杂，可利用 DCL 控制的权限有：CONNECT、SELECT、INSERT、UPDATE、DELETE、EXECUTE、USAGE、REFERENCES。 根据不同的 DBMS 以及不同的安全性实体，其支持的权限控制也有所不同。 2. 增删改查 增删改查，又称为 CRUD，数据库基本操作中的基本操作。 2.1 插入数据 INSERT INTO 语句用于向表中插入新记录。 插入完整的行 INSERT INTO user VALUES (10, 'root', 'root', 'xxxx@163.com'); 插入行的一部分 INSERT INTO user(username, password, email) VALUES ('admin', 'admin', 'xxxx@163.com'); 插入查询出来的数据 INSERT INTO user(username) SELECT name FROM account; 2.2 更新数据 UPDATE 语句用于更新表中的记录。 UPDATE user SET username='robot', password='robot' WHERE username = 'root'; 2.3 删除数据 DELETE 语句用于删除表中的记录。 TRUNCATE TABLE 可以清空表，也就是删除所有行。 删除表中的指定数据 DELETE FROM user WHERE username = 'robot'; 清空表中的数据 TRUNCATE TABLE user; 2.4 查询数据 SELECT 语句用于从数据库中查询数据。 DISTINCT 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。 LIMIT 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。 ASC ：升序（默认） DESC ：降序 查询单列 SELECT prod_name FROM products; 查询多列 SELECT prod_id, prod_name, prod_price FROM products; 查询所有列 ELECT * FROM products; 查询不同的值 SELECT DISTINCT vend_id FROM products; 限制查询结果 -- 返回前 5 行 SELECT * FROM mytable LIMIT 5; SELECT * FROM mytable LIMIT 0, 5; -- 返回第 3 ~ 5 行 SELECT * FROM mytable LIMIT 2, 3 LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)。 3. 子查询 子查询是嵌套在较大查询中的 SQL 查询。子查询也称为内部查询或内部选择，而包含子查询的语句也称为外部查询或外部选择。 子查询可以嵌套在 SELECT，INSERT，UPDATE 或 DELETE 语句内或另一个子查询中。 子查询通常会在另一个 SELECT 语句的 WHERE 子句中添加。 您可以使用比较运算符，如 >，，或 =。比较运算符也可以是多行运算符，如 IN，ANY 或 ALL。 子查询必须被圆括号 () 括起来。 内部查询首先在其父查询之前执行，以便可以将内部查询的结果传递给外部查询。执行过程可以参考下图： 3.1 子查询的子查询 SELECT cust_name, cust_contact FROM customers WHERE cust_id IN (SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = 'RGAN01')); 3.2 WHERE WHERE 子句用于过滤记录，即缩小访问数据的范围。 WHERE 后跟一个返回 true 或 false 的条件。 WHERE 可以与 SELECT，UPDATE 和 DELETE 一起使用。 可以在 WHERE 子句中使用的操作符 运算符 描述 = 等于 <> 不等于。注释：在 SQL 的一些版本中，该操作符可被写成 != > 大于 小于 >= 大于等于 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 IN 指定针对某个列的多个可能值 SELECT 语句中的 WHERE 子句 SELECT * FROM Customers WHERE cust_name = 'Kids Place'; UPDATE 语句中的 WHERE 子句 UPDATE Customers SET cust_name = 'Jack Jones' WHERE cust_name = 'Kids Place'; DELETE 语句中的 WHERE 子句 DELETE FROM Customers WHERE cust_name = 'Kids Place'; 3.3 IN 和 BETWEEN IN 操作符在 WHERE 子句中使用，作用是在指定的几个特定值中任选一个值。 BETWEEN 操作符在 WHERE 子句中使用，作用是选取介于某个范围内的值。 IN 示例 SELECT * FROM products WHERE vend_id IN ('DLL01', 'BRS01'); BETWEEN 示例 SELECT * FROM products WHERE prod_price BETWEEN 3 AND 5; 3.4 AND、OR、NOT AND、OR、NOT 是用于对过滤条件的逻辑处理指令。 AND 优先级高于 OR，为了明确处理顺序，可以使用 ()。 AND 操作符表示左右条件都要满足。 OR 操作符表示左右条件满足任意一个即可。 NOT 操作符用于否定一个条件。 AND 示例 SELECT prod_id, prod_name, prod_price FROM products WHERE vend_id = 'DLL01' AND prod_price OR 示例 SELECT prod_id, prod_name, prod_price FROM products WHERE vend_id = 'DLL01' OR vend_id = 'BRS01'; NOT 示例 SELECT * FROM products WHERE prod_price NOT BETWEEN 3 AND 5; 3.5 LIKE LIKE 操作符在 WHERE 子句中使用，作用是确定字符串是否匹配模式。 只有字段是文本值时才使用 LIKE。 LIKE 支持两个通配符匹配选项：% 和 _。 不要滥用通配符，通配符位于开头处匹配会非常慢。 % 表示任何字符出现任意次数。 _ 表示任何字符出现一次。 % 示例 SELECT prod_id, prod_name, prod_price FROM products WHERE prod_name LIKE '%bean bag%'; _ 示例 SELECT prod_id, prod_name, prod_price FROM products WHERE prod_name LIKE '__ inch teddy bear'; 4. 连接和组合 4.1 连接（JOIN） 如果一个 JOIN 至少有一个公共字段并且它们之间存在关系，则该 JOIN 可以在两个或多个表上工作。 连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。 JOIN 保持基表（结构和数据）不变。 JOIN 有两种连接类型：内连接和外连接。 内连接又称等值连接，使用 INNER JOIN 关键字。在没有条件语句的情况下返回笛卡尔积。 自连接可以看成内连接的一种，只是连接的表是自身而已。 自然连接是把同名列通过 = 测试连接起来的，同名列可以有多个。 内连接 vs 自然连接 内连接提供连接的列，而自然连接自动连接所有同名列。 外连接返回一个表中的所有行，并且仅返回来自次表中满足连接条件的那些行，即两个表中的列是相等的。外连接分为左外连接、右外连接、全外连接（Mysql 不支持）。 左外连接就是保留左表没有关联的行。 右外连接就是保留右表没有关联的行。 连接 vs 子查询 连接可以替换子查询，并且比子查询的效率一般会更快。 内连接（INNER JOIN） SELECT vend_name, prod_name, prod_price FROM vendors INNER JOIN products ON vendors.vend_id = products.vend_id; 自连接 SELECT c1.cust_id, c1.cust_name, c1.cust_contact FROM customers c1, customers c2 WHERE c1.cust_name = c2.cust_name AND c2.cust_contact = 'Jim Jones'; 自然连接（NATURAL JOIN） SELECT * FROM Products NATURAL JOIN Customers; 左连接（LEFT JOIN） SELECT customers.cust_id, orders.order_num FROM customers LEFT JOIN orders ON customers.cust_id = orders.cust_id; 右连接（RIGHT JOIN） SELECT customers.cust_id, orders.order_num FROM customers RIGHT JOIN orders ON customers.cust_id = orders.cust_id; 4.2 组合（UNION） UNION 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 UNION 中参与查询的提取行。 UNION 基本规则 所有查询的列数和列顺序必须相同。 每个查询中涉及表的列的数据类型必须相同或兼容。 通常返回的列名取自第一个查询。 默认会去除相同行，如果需要保留相同行，使用 UNION ALL。 只能包含一个 ORDER BY 子句，并且必须位于语句的最后。 应用场景 在一个查询中从不同的表返回结构数据。 对一个表执行多个查询，按一个查询返回数据。 组合查询 SELECT cust_name, cust_contact, cust_email FROM customers WHERE cust_state IN ('IL', 'IN', 'MI') UNION SELECT cust_name, cust_contact, cust_email FROM customers WHERE cust_name = 'Fun4All'; 4.3 JOIN vs UNION JOIN vs UNION JOIN 中连接表的列可能不同，但在 UNION 中，所有查询的列数和列顺序必须相同。 UNION 将查询之后的行放在一起（垂直放置），但 JOIN 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。 5. 函数 注意：不同数据库的函数往往各不相同，因此不可移植。本节主要以 Mysql 的函数为例。 5.1 文本处理 函数 说明 LEFT(str, length)、RIGHT(str, length) 返回具有指定长度的字符串的左边或右边部分 LOWER(str)、UPPER(str) 转换为小写或者大写 LTRIM(str)、RTIM(str) 去除左边或者右边的空格 LENGTH(str) 长度 SOUNDEX(str) 转换为语音值 其中， SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式。 SELECT * FROM mytable WHERE SOUNDEX(col1) = SOUNDEX('apple') 5.2 日期和时间处理 日期格式：YYYY-MM-DD 时间格式：HH:MM:SS 函 数 说 明 AddDate() 增加一个日期（天、周等） AddTime() 增加一个时间（时、分等） CurDate() 返回当前日期 CurTime() 返回当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DayOfWeek() 对于一个日期，返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Month() 返回一个日期的月份部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒部分 Time() 返回一个日期时间的时间部分 Year() 返回一个日期的年份部分 5.3 数值处理 函数 说明 SIN() 正弦 COS() 余弦 TAN() 正切 ABS() 绝对值 SQRT() 平方根 MOD() 余数 EXP() 指数 PI() 圆周率 RAND() 随机数 5.4 汇总 函 数 说 明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 AVG() 会忽略 NULL 行。 使用 DISTINCT 可以让汇总函数值汇总不同的值。 SELECT AVG(DISTINCT col1) AS avg_col FROM mytable 6. 排序和分组 6.1 ORDER BY ORDER BY 用于对结果集进行排序。 ASC ：升序（默认） DESC ：降序 可以按多个列进行排序，并且为每个列指定不同的排序方式 指定多个列的排序方向 SELECT * FROM products ORDER BY prod_price DESC, prod_name ASC; 6.2 GROUP BY GROUP BY 子句将记录分组到汇总行中。 GROUP BY 为每个组返回一个记录。 GROUP BY 通常还涉及聚合：COUNT，MAX，SUM，AVG 等。 GROUP BY 可以按一列或多列进行分组。 GROUP BY 按分组字段进行排序后，ORDER BY 可以以汇总字段来进行排序。 分组 SELECT cust_name, COUNT(cust_address) AS addr_num FROM Customers GROUP BY cust_name; 分组后排序 SELECT cust_name, COUNT(cust_address) AS addr_num FROM Customers GROUP BY cust_name ORDER BY cust_name DESC; 6.3 HAVING HAVING 用于对汇总的 GROUP BY 结果进行过滤。 HAVING 要求存在一个 GROUP BY 子句。 WHERE 和 HAVING 可以在相同的查询中。 HAVING vs WHERE WHERE 和 HAVING 都是用于过滤。 HAVING 适用于汇总的组记录；而 WHERE 适用于单个记录。 使用 WHERE 和 HAVING 过滤数据 SELECT cust_name, COUNT(*) AS num FROM Customers WHERE cust_email IS NOT NULL GROUP BY cust_name HAVING COUNT(*) >= 1; 7. 数据定义 DDL 的主要功能是定义数据库对象（如：数据库、数据表、视图、索引等）。 7.1 数据库（DATABASE） 创建数据库 CREATE DATABASE test; 删除数据库 DROP DATABASE test; 选择数据库 USE test; 7.2 数据表（TABLE） 创建数据表 普通创建 CREATE TABLE user ( id int(10) unsigned NOT NULL COMMENT 'Id', username varchar(64) NOT NULL DEFAULT 'default' COMMENT '用户名', password varchar(64) NOT NULL DEFAULT 'default' COMMENT '密码', email varchar(64) NOT NULL DEFAULT 'default' COMMENT '邮箱' ) COMMENT='用户表'; 根据已有的表创建新表 CREATE TABLE vip_user AS SELECT * FROM user; 删除数据表 DROP TABLE user; 修改数据表 添加列 ALTER TABLE user ADD age int(3); 删除列 ALTER TABLE user DROP COLUMN age; 修改列 ALTER TABLE `user` MODIFY COLUMN age tinyint; 添加主键 ALTER TABLE user ADD PRIMARY KEY (id); 删除主键 ALTER TABLE user DROP PRIMARY KEY; 7.3 视图（VIEW） 定义 视图是基于 SQL 语句的结果集的可视化的表。 视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。 作用 简化复杂的 SQL 操作，比如复杂的联结； 只使用实际表的一部分数据； 通过只给用户访问视图的权限，保证数据的安全性； 更改数据格式和表示。 创建视图 CREATE VIEW top_10_user_view AS SELECT id, username FROM user WHERE id 删除视图 DROP VIEW top_10_user_view; 7.4 索引（INDEX） 作用 通过索引可以更加快速高效地查询数据。 用户无法看到索引，它们只能被用来加速查询。 注意 更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。 唯一索引 唯一索引表明此索引的每一个索引值只对应唯一的数据记录。 创建索引 CREATE INDEX user_index ON user (id); 创建唯一索引 CREATE UNIQUE INDEX user_index ON user (id); 删除索引 ALTER TABLE user DROP INDEX user_index; 7.5 约束 SQL 约束用于规定表中的数据规则。 如果存在违反约束的数据行为，行为会被约束终止。 约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。 约束类型 NOT NULL - 指示某列不能存储 NULL 值。 UNIQUE - 保证某列的每行必须有唯一的值。 PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。 FOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。 CHECK - 保证列中的值符合指定的条件。 DEFAULT - 规定没有给列赋值时的默认值。 创建表时使用约束条件： CREATE TABLE Users ( Id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增Id', Username VARCHAR(64) NOT NULL UNIQUE DEFAULT 'default' COMMENT '用户名', Password VARCHAR(64) NOT NULL DEFAULT 'default' COMMENT '密码', Email VARCHAR(64) NOT NULL DEFAULT 'default' COMMENT '邮箱地址', Enabled TINYINT(4) DEFAULT NULL COMMENT '是否有效', PRIMARY KEY (Id) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT='用户表'; 8. 事务处理 不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。 MySQL 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。 通过 set autocommit=0 可以取消自动提交，直到 set autocommit=1 才会提交；autocommit 标记是针对每个连接而不是针对服务器的。 指令 START TRANSACTION - 指令用于标记事务的起始点。 SAVEPOINT - 指令用于创建保留点。 ROLLBACK TO - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 START TRANSACTION 语句处。 COMMIT - 提交事务。 -- 开始事务 START TRANSACTION; -- 插入操作 A INSERT INTO `user` VALUES (1, 'root1', 'root1', 'xxxx@163.com'); -- 创建保留点 updateA SAVEPOINT updateA; -- 插入操作 B INSERT INTO `user` VALUES (2, 'root2', 'root2', 'xxxx@163.com'); -- 回滚到保留点 updateA ROLLBACK TO updateA; -- 提交事务，只有操作 A 生效 COMMIT; 9. 权限控制 GRANT 和 REVOKE 可在几个层次上控制访问权限： 整个服务器，使用 GRANT ALL 和 REVOKE ALL； 整个数据库，使用 ON database.*； 特定的表，使用 ON database.table； 特定的列； 特定的存储过程。 新创建的账户没有任何权限。 账户用 username@host 的形式定义，username@% 使用的是默认主机名。 MySQL 的账户信息保存在 mysql 这个数据库中。 USE mysql; SELECT user FROM user; 复制代码 创建账户 CREATE USER myuser IDENTIFIED BY 'mypassword'; 修改账户名 UPDATE user SET user='newuser' WHERE user='myuser'; FLUSH PRIVILEGES; 删除账户 DROP USER myuser; 查看权限 SHOW GRANTS FOR myuser; 授予权限 GRANT SELECT, INSERT ON *.* TO myuser; 删除权限 REVOKE SELECT, INSERT ON *.* FROM myuser; 更改密码 SET PASSWORD FOR myuser = 'mypass'; 10. 存储过程 存储过程可以看成是对一系列 SQL 操作的批处理； 使用存储过程的好处 代码封装，保证了一定的安全性； 代码复用； 由于是预先编译，因此具有很高的性能。 创建存储过程 命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。 包含 in、out 和 inout 三种参数。 给变量赋值都需要用 select into 语句。 每次只能给一个变量赋值，不支持集合的操作。 创建存储过程 DROP PROCEDURE IF EXISTS `proc_adder`; DELIMITER ;; CREATE DEFINER=`root`@`localhost` PROCEDURE `proc_adder`(IN a int, IN b int, OUT sum int) BEGIN DECLARE c int; if a is null then set a = 0; end if; if b is null then set b = 0; end if; set sum = a + b; END ;; DELIMITER ; 使用存储过程 set @b=5; call proc_adder(2,@b,@s); select @s as sum; 11. 游标 游标（cursor）是一个存储在 DBMS 服务器上的数据库查询，它不是一条 SELECT 语句，而是被该语句检索出来的结果集。 在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。 使用游标的四个步骤： 声明游标，这个过程没有实际检索出数据； 打开游标； 取出数据； 关闭游标； DELIMITER $ CREATE PROCEDURE getTotal() BEGIN DECLARE total INT; -- 创建接收游标数据的变量 DECLARE sid INT; DECLARE sname VARCHAR(10); -- 创建总数变量 DECLARE sage INT; -- 创建结束标志变量 DECLARE done INT DEFAULT false; -- 创建游标 DECLARE cur CURSOR FOR SELECT id,name,age from cursor_table where age>30; -- 指定游标循环结束时的返回值 DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = true; SET total = 0; OPEN cur; FETCH cur INTO sid, sname, sage; WHILE(NOT done) DO SET total = total + 1; FETCH cur INTO sid, sname, sage; END WHILE; CLOSE cur; SELECT total; END $ DELIMITER ; -- 调用存储过程 call getTotal(); 12. 触发器 触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。 可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。 MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程。 BEGIN 和 END 当触发器的触发条件满足时，将会执行 BEGIN 和 END 之间的触发器执行动作。 🔔 注意：在 MySQL 中，分号 ; 是语句结束的标识符，遇到分号表示该段语句已经结束，MySQL 可以开始执行了。因此，解释器遇到触发器执行动作中的分号后就开始执行，然后会报错，因为没有找到和 BEGIN 匹配的 END。 这时就会用到 DELIMITER 命令（DELIMITER 是定界符，分隔符的意思）。它是一条命令，不需要语句结束标识，语法为：DELIMITER new_delemiter。new_delemiter 可以设为 1 个或多个长度的符号，默认的是分号 ;，我们可以把它修改为其他符号，如 $ - DELIMITER $ 。在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了 $，才认为是语句结束。注意，使用完之后，我们还应该记得把它给修改回来。 NEW 和 OLD MySQL 中定义了 NEW 和 OLD 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。 在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据； 在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据； 在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据； 使用方法： NEW.columnName （columnName 为相应数据表某一列名） 12.1 创建触发器 提示：为了理解触发器的要点，有必要先了解一下创建触发器的指令。 CREATE TRIGGER 指令用于创建触发器。 语法： CREATE TRIGGER trigger_name trigger_time trigger_event ON table_name FOR EACH ROW BEGIN trigger_statements END; 说明： trigger_name：触发器名 trigger_time: 触发器的触发时机。取值为 BEFORE 或 AFTER。 trigger_event: 触发器的监听事件。取值为 INSERT、UPDATE 或 DELETE。 table_name: 触发器的监听目标。指定在哪张表上建立触发器。 FOR EACH ROW: 行级监视，Mysql 固定写法，其他 DBMS 不同。 trigger_statements: 触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 ; 来结尾 示例： DELIMITER $ CREATE TRIGGER `trigger_insert_user` AFTER INSERT ON `user` FOR EACH ROW BEGIN INSERT INTO `user_history`(user_id, operate_type, operate_time) VALUES (NEW.id, 'add a user', now()); END $ DELIMITER ; 12.2 查看触发器 SHOW TRIGGERS; 12.3 删除触发器 DROP TRIGGER IF EXISTS trigger_insert_user; "},"sql/mysql.html":{"url":"sql/mysql.html","title":"MySQL语法","keywords":"","body":"MySQL 常用命令 请注意： 命令输入在 mysql> 之后； 命令用 ; 或 \\g 结束，换句话说，仅按 Enter 不执行命令； 输入 help 或 \\h 获得帮助，也可以输入更多的文本获得特定命令的帮助（如，输入 help select 获得使用 SELECT 语句的帮助）； 输入 quit 或 exit 退出命令行实用程序。 连接 MySQL mysql [-h 主机地址 [-P 端口号]] -u 用户名 -p[密码] ps：-h 和主机地址、-P 和端口号、-u 和用户名之间要不要空格都可以，但是，-p 和密码不能有空格。 列出所有的数据库 show databases; 选择数据库 use 数据库名; 列出所有的表 show tables; 查看表结构 desc 表名; 或 describe 表名; 或 show columns from 表名; 显示广泛的服务器状态信息 show status; 显示创建特定数据库或表的 MySQL 语句； show create database 数据库名; show create table 表名; distinct distinct 关键字的主要作用就是对数据库表中一个或者多个字段重复的数据进行过滤。 limit select * from table_name limit 查询的条数 offset 起始索引(从0开始); 或 select * from table_name limit 起始索引(从0开始),查询的条数; 注意：两种方式的参数顺序不一样 order by 注意：ORDER BY 子句的位置在指定一条 ORDER BY 子句时，应该保证它是 SELECT 语句中最后一条子句。如果它不是最后的子句，将会出错。 提示：通过非选择列进行排序通常，ORDER BY 子句中使用的列将是为显示而选择的列。但是，实际上并不一定要这样，用非检索的列排序数据是完全合法的。 sql 查询慢的原因 数据查询过慢一般是索引问题，可能是因为选错索引，也可能是因为查询的行数太多。 客户端和数据库连接数过小，会限制sql的查询并发数，增大连接数可以提升速度。 innodb里会有一层内存buffer pool用于提升查询速度，命中率一般>99%，如果低于这个值，可以考虑增大buffer pool的大小，这样也可以提升速度。 查询缓存（query cache）确实能为查询提速，但一般不建议打开，因为限制比较大，并且8.0以后的Mysql里已经将这个功能干掉了。 常用的文本处理函数 函数 说明 LEFT()（或使用子字符串函数） 返回字符串左边的字符 LENGTH()（也使用DATALENGTH()或LEN()） 返回字符串的长度 LOWER() 将字符串转换为小写 LTRIM() 去掉字符串左边的空格 RIGHT()（或使用子字符串函数） 返回字符串右边的字符 RTRIM() 去掉字符串右边的空格 SUBSTR()或SUBSTRING() 提取字符串的组成部分 SOUNDEX() 返回字符串的SOUNDEX值 UPPER() 将字符串转换为大写 日期和时间处理函数 函数 说明 YEAR() 从日期中提取年份 MONTH() 从日期中提取月份 DAY() 从日期中提取日 例如：查询2020年所有的订单： select * from tb_order where year(order_time) = 2020; select * from tb_order where year(create_time) = 2020 and month(create_time) = 4 and day(create_time) = 3 数值处理函数 函数 说明 ABS() 返回一个数的绝对值 COS() 返回一个角度的余弦 EXP() 返回一个数的指数值 PI() 返回圆周率π 的值 SIN() 返回一个角度的正弦 SQRT() 返回一个数的平方根 TAN() 返回一个角度的正切 聚集函数 函数 说明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 COUNT() 函数：说明:NULL 值，如果指定列名，则 COUNT() 函数会忽略指定列的值为NULL的行，但如果 COUNT() 函数中用的是星号（*)，则不忽略。 MAX() 函数：提示：对非数值数据使用 MAX()，虽然 MAX() 一般用来找出最大的数值或日期值，但许多（并非所有） DBMS 允许将它用来返回任意列中的最大值，包括返回文本列中的最大值。在用于文本数据时，MAX() 返回按该列排序后的最后一行。说明：NULL 值 MAX()函数忽略列值为 NULL 的行。 MIN() 函数：提示：对非数值数据使用 MIN() 虽然 MIN()一般用来找出最小的数值或日期值，但许多（并非所有） DBMS 允许将它用来返回任意列中的最小值，包括返回文本列中的最小值。在用于文本数据时，MIN()返回该列排序后最前面的行。说明：NULL 值 MIN()函数忽略列值为 NULL 的行。 SUM() 函数：提示：在多个列上进行计算，如本例所示，利用标准的算术操作符，所有聚集函数都可用来执行多 个列上的计算。说明：NULL 值 SUM()函数忽略列值为 NULL 的行。 聚集不同值 对所有行执行计算，指定 ALL 参数或不指定参数（因为 ALL 是默认行为）。 只包含不同的值，指定 DISTINCT 参数。 提示：ALL 为默认， ALL 参数不需要指定，因为它是默认行为。如果不指定 DISTINCT，则假定为 ALL。 注意：DISTINCT 不能用于 COUNT() 如果指定列名，则 DISTINCT 只能用于 COUNT()。DISTINCT 不能用于 COUNT()。类似地，DISTINCT 必须使用列名，不能用于计算或表达式。 提示：将 DISTINCT 用于 MIN()和 MAX() 虽然 DISTINCT 从技术上可用于 MIN()和 MAX()，但这样做实际上没 有价值。一个列中的最小值和最大值不管是否只考虑不同值，结果都是相同的。 说明：其他聚集参数 除了这里介绍的 DISTINCT 和 ALL 参数，有的 DBMS 还支持其他参数， 如支持对查询结果的子集进行计算的 TOP 和 TOP PERCENT。为了解具体的 DBMS 支持哪些参数，请参阅相应的文档。 数据分组 在使用 GROUP BY 子句前，需要知道一些重要的规定。 GROUP BY 子句可以包含任意数目的列，因而可以对分组进行嵌套，更细致地进行数据分组。 如果在 GROUP BY 子句中嵌套了分组，数据将在最后指定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。 GROUP BY 子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT 中使用表达式，则必须在 GROUP BY 子句中指定相同的表达式。不能使用别名。 大多数SQL 实现不允许GROUP BY 列带有长度可变的数据类型（如文本或备注型字段）。 除聚集计算语句外，SELECT 语句中的每一列都必须在GROUP BY 子句中给出。 如果分组列中包含具有NULL 值的行，则NULL 将作为一个分组返回。如果列中有多行NULL 值，它们将分为一组。 GROUP BY 子句必须出现在WHERE 子句之后，ORDER BY 子句之前。 说明：HAVING 和 WHERE 的差别 WHERE 过滤行，而 HAVING 过滤分组。 这里有另一种理解方法，WHERE 在数据分组前进行过滤，HAVING 在数据分组后进行过滤。这是一个重要的区别，WHERE 排除的行不包括在分组中。这可能会改变计算值，从而影响HAVING 子句中基于这些值过滤掉的分组。 说明：使用HAVING 和 WHERE HAVING 与 WHERE 非常类似，如果不指定GROUP BY，则大多数DBMS会同等对待它们。不过，你自己要能区分这一点。使用HAVING 时应该结合GROUP BY 子句，而WHERE 子句用于标准的行级过滤。 SELECT子句及其顺序 子 句 说 明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 子查询 注意：只能是单列 作为子查询的SELECT 语句只能查询单个列。企图检索多个列将返回错误。 注意：子查询和性能 使用子查询并不总是执行这类数据检索的最有效方法。 "},"framework/framework.html":{"url":"framework/framework.html","title":"框架","keywords":"","body":""},"tools/tools.html":{"url":"tools/tools.html","title":"开发工具","keywords":"","body":"主要收录一些自己在日常开发中经常使用的一些开发和使用工具，仅供自己检查使用。 "},"tools/idea/idea.html":{"url":"tools/idea/idea.html","title":"IDEA","keywords":"","body":"1. IDEA 使用技巧 1.1 最爱的[演出模式] 我们可以使用【Presentation Mode】，将 IDEA 弄到最大，可以让你只关注一个类里面的代码，进行毫无干扰的 coding。 可以使用 Alt + V 快捷键，弹出 View 视图，选择 Appearance ，然后选择 Enter Presentation Mode。效果如下： 这个模式的好处就是，可以让你更加专注，因为你只能看到特定某个类的代码。可能读者会问，进入这个模式后，我想看其他类的代码怎么办？这个时候，就要考验你快捷键的熟练程度了。你可以使用 Ctrl + E 弹出最近使用的文件。又或者使用 Ctrl + N 和 Ctrl + Shift + N 定位文件。 如何退出这个模式呢？很简单，使用 Alt + V 弹出 View 视图，然后选择 Exit Presentation Mode 即可。但是我强烈建议你不要这么做，因为你是可以在 Enter Presentation Mode 模式下在IDEA里面做任何事情的。当然前提是，你对IDEA足够熟练。 1.2 神奇的 Inject language 如果你使用 IDEA 在编写 JSON 字符串的时候，然后要一个一个 \\ 去转义双引号的话，就实在太不应该了，又烦又容易出错。在 IDEA 可以使用 Inject language 帮我们自动转义双引号。 先将焦点定位到双引号里面，使用 Alt + Enter 快捷键弹出 Inject language 视图，并选中 Inject language or reference。 选择后,切记，要直接按下 Enter 回车键，才能弹出 Inject language 列表。在列表中选择 json 组件。 选择完后。鼠标焦点自动会定位在双引号里面，这个时候你再次使用 Alt + Enter 就可以看到选中 Edit JSON Fragment 并回车，就可以看到编辑 JSON 文件的视图了。 可以看到 IDEA 确实帮我们自动转义双引号了。如果要退出编辑 JSON 信息的视图，只需要使用 Ctrl + F4 快捷键即可。 Inject language 可以支持的语言和操作多到你难以想象，读者可以自行研究。 1.3 使用快捷键移动分割线 假设有下面的场景，某个类的名字在 project 视图里被挡住了某一部分。 你想完整的看到类的名字，该怎么做。一般都是使用鼠标来移动分割线，但是这样子效率太低了。可以使用 Alt + 1 把鼠标焦点定位到 project 视图里，然后直接使用 Ctrl + Shift + 左右箭头 来移动分割线。 1.4 给行尾加分号 Ctrl + Shift + Enter 其实是表示为您收尾的意思，不只是用来给行尾加分号的，IDEA 还会自动帮你收尾，加上大括号的。 1.5 不要动不动就使用 IDEA 的重构功能 IDEA 的重构功能非常强大，但是也有时候，在单个类里面，如果只是想批量修改某个文本，大可不必使用到重构的功能。比如说： 上面的代码中，有5个地方用到了 rabbitTemplate 文本，如何批量修改呢？ 首先是使用 Ctrl + W 选中 rabbitTemplate 这个文本,然后依次使用5次 Alt + J 快捷键，逐个选中，这样五个文本就都被选中并且高亮起来了，这个时候就可以直接批量修改了。 1.6 定位到导航栏 Alt + Home 然后配合方向键使用。 1.7 把鼠标定位到 project 视图里 当工程里的包和类非常多的时候，有时候我们想知道当前类在 project 视图里是处在哪个位置。 可以先使用 Alt + F1，弹出 Select in 视图，然后选择 Project View 中的 Project，回车，就可以立刻定位到类的位置了。 那如何从 project 跳回代码里呢？可以直接使用 Esc 退出 project 视图，或者直接使用 F4，跳到代码里。 1.8 强大的 symbol 如果你依稀记得某个方法名字几个字母，想在 IDEA 里面找出来，可以怎么做呢？ 直接使用 Ctrl + Shift + Alt + N，使用 symbol 来查找即可。 例如： @Service public class DemoIDEA { public void changeUserName() { System.out.println(\"changeUserName\"); } public void checkUser() { System.out.println(\"checkUser\"); } } 你想找到 checkUser 方法。直接输入 user 即可。 如果你记得某个业务类里面有某个方法，那也可以使用首字母找到类,然后加个.，再输入方法名字也是可以的。 例如： DI.check 1.9 如何找目录 使用 Ctrl + Shift + N 后，使用 /，然后输入目录名字即可. 1.10 自动生成 not null 判断语句 自动生成 not null 这种 if 判断，在 IDEA 里有很多种办法，其中一种办法你可能没想到。 当我们使用 对象. 后，直接输入 notnull 并回车，IDEA 就好自动生成 if 判断了。 1.11 按照模板找内容 这个也是我非常喜欢的一个功能，可以根据模板来找到与模板匹配的代码块。比如说： 想在整个工程里面找到所有的 try catch 语句,但是 catch 语句里面没有做异常处理的。 catch 语句里没有处理异常是极其危险的。我们可以 IDEA 里面方便找到所有这样的代码。 首先使用 Ctrl + Shift + A 快捷键弹出 action 框，然后输入 Search Struct ，选择 Search Structurally 后，回车，跳转到模板视图。 点击 Existing Templates 按钮，选择 try 模板。为了能找出 catch 里面没有处理异常的代码块，我们需要配置一下 CatchStatement 的 Maximum count 的值，将其设置为1。 点击 Edit Variables 按钮，在界面修改 Maximum count 的值。 最后点击 find 按钮，就可以找出 catch 里面没有处理异常的代码了。 1.12 后缀完成 参考地址 Postfix Completion (下称 Postfix) 是一种通过 . + 模板 Key 来对当前已经输出的表达式，添加和应用预设代码模板的编码增强能力。 其核心要解决的问题是，将编码过程中一些通用的代码结构范式进行抽象和沉淀，并能在同类型的场景下，通过 . + 模板 Key 的方式进行唤醒和复用。 var 快速定义一个局部变量，自带 IDE 的类型推断 notnull 快速进行 NPE 的判空保护 nn 同 notnull，是它的简写，推荐用这个，更加便捷 try catch 快速对当前语句添加 try catch 异常捕获，同时 IDE 还会对 catch 中的 Exception 自动做类型推断 cast/castvar 快速实现类型强转，不需要反复使用()包裹和光标切换；配合instanceof使用时还能自动实现cast类型的推断 if 快速实现 if 判断的代码范式 throw 快速实现抛异常 for 快速实现集合或数组的迭代 fori 快速实现集合或数组的带索引值迭代；同时对整型数字也支持 sout/soutv 快速实现（不带参数/带参数）的打印功能 return 快速实现方法中的值返回逻辑 format 快速实现字符串格式化 1.13 模板 参考地址 psfs 定义字符串常量 main 添加入口函数 sout 实现日志输出 2. IDEA 常用快捷键 2.1 Ctrl 快捷键 介绍 Ctrl + B 进入光标所在的方法/变量的接口或是定义处，等效于 Ctrl + 左键单击 Ctrl + C 复制光标所在行 或 复制选择内容 Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备） Ctrl + E 显示最近打开的文件记录列表 Ctrl + F 在当前文件进行文本查找 （必备） Ctrl + G 在当前文件跳转到指定行处 Ctrl + H 显示当前类的层次结构 Ctrl + I 选择可继承的方法 Ctrl + J 插入自定义动态代码模板 Ctrl + K 版本控制提交项目，需要此项目有加入到版本控制才可用 Ctrl + L 搜索切换到下一个 Ctrl + M 将光标位置移动到屏幕中间位置 Ctrl + N 根据输入的 类名 查找类文件 Ctrl + O 选择可重写的方法 Ctrl + P 方法参数提示显示 Ctrl + Q 光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容 Ctrl + R 在当前文件进行文本替换 （必备） Ctrl + T 版本控制更新项目，需要此项目有加入到版本控制才可用 Ctrl + U 前往当前光标所在的方法的父类的方法 / 接口定义 Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备） Ctrl + X 剪切光标所在行 或 剪切选择内容 Ctrl + Y 删除光标所在行 或 删除选中的行 （必备） Ctrl + Z 撤销 （必备） Ctrl + + 展开代码 Ctrl + - 折叠代码 Ctrl + ~ 共有五种可供选择的操作（比较强大） Ctrl + / 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备） Ctrl + [ 移动光标到当前所在代码的花括号开始位置 Ctrl + ] 移动光标到当前所在代码的花括号结束位置 Ctrl + F1 在光标所在的错误代码出显示错误信息 Ctrl + F2 在 debug 模式下结束 debug 运行 Ctrl + F3 调转到所选中的词的下一个引用位置 Ctrl + F4 关闭当前编辑文件 Ctrl + F6 修改方法签名 Ctrl + F8 在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点 Ctrl + F9 执行 Make Project 操作 Ctrl + F11 选中文件 / 文件夹，使用助记符设定 / 取消书签 Ctrl + F12 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选 Ctrl + Tab 编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口 Ctrl + Enter 智能分隔行 Ctrl + End 跳到文件尾 Ctrl + Home 跳到文件头 Ctrl + Space 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备） Ctrl + Delete 删除光标后面的单词或是中文句 Ctrl + BackSpace 删除光标前面的单词或是中文句 Ctrl + 1,2,3...9 定位到对应数值的书签位置 Ctrl + 左键单击 在打开的文件标题上，弹出该文件路径 Ctrl + 光标定位 按 Ctrl 不要松开，会显示光标所在的类信息摘要 Ctrl + 左方向键 光标跳转到当前单词 / 中文句的左侧开头位置 Ctrl + 右方向键 光标跳转到当前单词 / 中文句的右侧开头位置 Ctrl + 前方向键 等效于鼠标滚轮向前效果 Ctrl + 后方向键 等效于鼠标滚轮向后效果 2.2 Alt 快捷键 介绍 Alt + J 可以选中多个相同内容，批量修改 Alt + P/A 配合 Ctrl + R 一起使用，逐个 / 全部替换 Alt + Q 弹出一个提示，显示当前类的声明 / 上下文信息 Alt + W 打开 Window 菜单，Alt 配合其他菜单的首字母可以打开其他的菜单 Alt + ` 显示版本控制常用操作菜单弹出层 Alt + 3 显示上次查找方法引用的地方 Alt + 7 在 Structture 显示当前文件结构层，可以用鼠标进行筛选 Alt + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 Alt + F2 对于前面页面，显示各类浏览器打开目标选择弹出层 Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示 Alt + F7 查找光标所在的方法 / 变量 / 类被调用的地方 Alt + F8 在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果 Alt + F9 在 debug 模式下运行到鼠标所在的行 Alt + Home 定位 / 显示到当前文件的 Navigation Bar Alt + Enter IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备） Alt + Insert 代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 Alt + 左方向键 按左方向切换当前已打开的文件视图 Alt + 右方向键 按右方向切换当前已打开的文件视图 Alt + 前方向键 当前光标跳转到当前文件的前一个方法名位置 Alt + 后方向键 当前光标跳转到当前文件的后一个方法名位置 Alt + 1,2,3...9 显示对应数值的选项卡，其中 1 是 Project 用得最多 2.3 Shift 快捷键 介绍 Shift + F1 如果有外部文档可以连接外部文档 Shift + F2 跳转到上一个高亮错误 或 警告位置 Shift + F3 在查找模式下，查找匹配上一个 Shift + F4 对当前打开的文件，使用新Windows窗口打开，旧窗口保留 Shift + F6 对文件 / 文件夹 重命名 Shift + F7 在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法 Shift + F8 在 Debug 模式下，跳出，表现出来的效果跟 F9 一样 Shift + F9 等效于点击工具栏的 Debug 按钮 Shift + F10 等效于点击工具栏的 Run 按钮 Shift + F11 弹出书签显示层 Shift + Tab 取消缩进 Shift + ESC 隐藏当前 或 最后一个激活的工具窗口 Shift + End 选中光标到当前行尾位置 Shift + Home 选中光标到当前行头位置 Shift + Enter 开始新一行。光标所在行下空出一行，光标定位到新行位置 Shift + 左键单击 在打开的文件名上按此快捷键，可以关闭当前打开文件 Shift + 滚轮前后滚动 当前文件的横向滚动轴滚动 2.4 Ctrl + Alt 快捷键 介绍 Ctrl + Alt + B 在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 Ctrl + Alt + H 查看方法在哪里被调用 Ctrl + Alt + I 光标所在行或选中部分进行自动代码缩进，有点类似格式化 Ctrl + Alt + J 弹出模板选择窗口，将选定的代码加入动态模板中 Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + M 快速抽取方法 Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + S 打开 IntelliJ IDEA 系统设置 Ctrl + Alt + T 对选中的代码弹出环绕选项弹出层 Ctrl + Alt + V 快速引进变量 Ctrl + Alt + Y 同步、刷新 Ctrl + Alt + F7 显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来 Ctrl + Alt + F8 在 debug 模式下，快速查看变量的值 Ctrl + Alt + F11 切换全屏模式 Ctrl + Alt + Enter 光标所在行上空出一行，光标定位到新行 Ctrl + Alt + Home 弹出跟当前文件有关联的文件弹出层 Ctrl + Alt + Space 类名自动完成 Ctrl + Alt + 左方向键 退回到上一个操作的地方 （必备）（注意与其他软件快捷键冲突） Ctrl + Alt + 右方向键 前进到上一个操作的地方 （必备）（注意与其他软件快捷键冲突） Ctrl + Alt + 前方向键 在查找模式下，跳到上个查找的文件 Ctrl + Alt + 后方向键 在查找模式下，跳到下个查找的文件 2.5 Ctrl + Shift 快捷键 介绍 Ctrl + Shift + A 查找动作 / 设置 Ctrl + Shift + B 跳转到类型声明处 Ctrl + Shift + C 复制当前文件磁盘路径到剪贴板 Ctrl + Shift + E 显示最近修改的文件列表的弹出层 Ctrl + Shift + F 根据输入内容查找整个项目或指定目录内文件 （必备） Ctrl + Shift + H 显示方法层次结构 Ctrl + Shift + I 快速查看光标所在的方法或类的定义 Ctrl + Shift + J 自动将下一行合并到当前行末尾 （必备） Ctrl + Shift + L 搜索切换到上一个 Ctrl + Shift + N 通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠，支持正则表达式，例如：查找 JsonTranscode，只需要输入JT（必备） Ctrl + Shift + O 重新加载 maven 改变 Ctrl + Shift + P 引入局部变量 Ctrl + Shift + R 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备） Ctrl + Shift + T 对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 Ctrl + Shift + U 对选中的代码进行大 / 小写轮流转换 （必备） Ctrl + Shift + V 弹出缓存的最近拷贝的内容管理器弹出层 Ctrl + Shift + W 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备） Ctrl + Shift + Z 取消撤销 （必备） Ctrl + Shift + / 代码块注释 （必备） Ctrl + Shift + [ 选中从光标所在位置到它的顶部中括号位置 Ctrl + Shift + ] 选中从光标所在位置到它的底部中括号位置 Ctrl + Shift + + 展开所有代码 Ctrl + Shift + - 折叠所有代码 Ctrl + Shift + F7 高亮显示所有该选中文本，按Esc高亮消失或者您可以查看方法中可能抛出某些异常的所有语句。在 throws 语句前插入符号，然后按 Ctrl+Shift+F7。 Ctrl + Shift + F8 在 Debug 模式下，指定断点进入条件 Ctrl + Shift + F9 编译选中的文件 / 包 / Module Ctrl + Shift + F10 Run method / project Ctrl + Shift + F12 编辑器最大化 Ctrl + Shift + Space 智能代码提示 Ctrl + Shift + Enter 自动结束代码，行末自动添加分号 （必备） Ctrl + Shift + Backspace 退回到上次修改的地方 Ctrl + Shift + 1,2,3...9 快速添加指定数值的书签 Ctrl + Shift + 左方向键 在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句 Ctrl + Shift + 右方向键 在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 Ctrl + Shift + 左方向键 在光标焦点是在工具选项卡上，缩小选项卡区域 Ctrl + Shift + 右方向键 在光标焦点是在工具选项卡上，扩大选项卡区域 Ctrl + Shift + 前方向键 光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 Ctrl + Shift + 后方向键 光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 2.6 Alt + Shift 快捷键 介绍 Alt + Shift + C 查看最近操作项目的变化情况列表 Alt + Shift + F 显示添加到收藏夹弹出层 Alt + Shift + J 向上取消多选的内容 Alt + Shift + N 选择 / 添加 task Alt + Shift + I 查看项目当前文件 Alt + Shift + F7 在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入 Alt + Shift + F9 弹出 Debug 的可选择菜单 Alt + Shift + F10 弹出 Run 的可选择菜单 Alt + Shift + Enter 根据提示替换内容，配合 F2 和 Ctrl + F1 一起使用 Alt + Shift + 左键双击 选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 Alt + Shift + 前方向键 移动光标所在行向上移动 Alt + Shift + 后方向键 移动光标所在行向下移动 2.7 Ctrl + Shift + Alt 快捷键 介绍 Ctrl + Shift + Alt + C 复制参考信息 Ctrl + Shift + Alt + L 重新格式化代码 Ctrl + Shift + Alt + N 前往指定的变量 / 方法 Ctrl + Shift + Alt + S 打开当前项目设置 Ctrl + Shift + Alt + T 打开重构菜单 Ctrl + Shift + Alt + V 无格式黏贴 2.8 其他 快捷键 介绍 F2 跳转到下一个高亮错误 或 警告位置 （必备） F3 在查找模式下，定位到下一个匹配处 F4 编辑源 F7 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 F8 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 F9 在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上 F11 添加书签 F12 回到前一个工具窗口 Tab 缩进 ESC 从工具窗口进入代码文件窗口 Double Press Shift 弹出 Search Everywhere 弹出层 "},"tools/datagrip/datagrip.html":{"url":"tools/datagrip/datagrip.html","title":"DataGrip","keywords":"","body":"最近看到一款数据库客户端工具，DataGrip，是大名鼎鼎的 JetBrains 公司出品的，就是那个出品 Intellij IDEA 的公司。DataGrip 是一款数据库管理客户端工具，方便连接到数据库服务器，执行 sql、创建表、创建索引以及导出数据等。 之前试用的客户端工具是 dbvisualizer，但是在试用了 DataGrip 以后，我就决定抛弃 dbvisualizer。 我相信，当你第一眼看到 DataGrip 以后，会有一种惊艳的感觉，就好比你第一眼看到一个姑娘，就是那么一瞥，你对自己说，就是她了！ 废话不多说，来看看 DataGrip 的常用功能。 DataGrip 下载链接如下https://www.jetbrains.com/datagrip/download。安装过程也很简单，双击安装，下一步，中间会让你选择主题，本人选择的是经典的 Darcula，安装完成后，启动，界面如下 相信使用过 IDEA 的同学会感到很亲切。接下来管理数据库驱动。DataGrip 支持主流的数据库，File->DataSource 也可以在 Database 视图中展开绿色的+号，添加数据库连接 选择需要连接的数据库类型 在面板中，左上部分列出了已经建立的数据库连接，点击各项，右侧会展示当前连接的配置信息，General 面板中，可以配置数据库连接的信息，如主机、用户名、密码等，不同数据库配置信息不完全相同，填入数据库 URL，注意，URL 后有个选项，可以选择直接填入 url，那么就不需要单独填主机名、端口等信息了。 Driver 部分显示数据库驱动信息，如果还没有下载过驱动，底部会有个警告，提示缺少驱动 点击 Driver 后的数据库类型，会跳转到驱动下载页面，点击 download，下载完会显示驱动包 如果下载的驱动有问题，可以手动添加本地驱动包，在试用过程中，创建 Oracle 连接时，下载的驱动包就有问题，提示缺少 class，点击右侧绿色的 + 号，选择本地下载好的 jar 包，通过右侧上下箭头，将导入的 jar 包移到最上位置就 OK 了 点击 Test Connection，查看配置是否正确，接下来就可以使用了。 打开 DataGrip，选择 File->Settings，当前面板显示了常用设置项 基本上默认设置就足够了，要更改设置也很简单，左侧菜单已经分类好了，第一项是数据库相关的配置，第二项是配置外观的，在这里可以修改主题，key map 修改快捷键，editor 配置编辑器相关设置，在这里可以修改编辑器字体，展开 edit 项，Editor->Color & Fonts->Font 需要将当前主题保存一下，点击save as，起个名，选择重命名后的主题就能修改了，这里我选择习惯的 Conurier New 字体，大小为14号，点击右下角的 apply，点击 OK 其他的没啥好设置的了。 接下来，我们来使用 DataGrip 完成数据库的常用操作，包括查询数据、修改数据，创建数据库、表等。 左上区域显示了当前数据库连接，展开后会显示数据库表等信息，如果展开后没有任何信息，需要选中数据库连接，点击上面的旋转图标同步一下，下方有个 More Schema 选项，点击可以切换不同的 schema。 右键选中的数据库连接，选择 open console(快捷键：Ctrl + Shift + Q)，就可以在右侧的控制台中书写 sql 语句了。 DataGrip 的智能提示非常爽，无论是标准的 sql 关键字，还是表名、字段名，甚至数据库特定的字段，都能提示，不得不感叹这智能提示太强大了，Intellij IDEA 的智能提示也是秒杀 eclipse。 写完 sql 语句后，可以选中，电子左上侧绿色箭头执行 也可以使用快捷键 Ctrl + Enter，选中情况下，会直接执行该 sql，未选中情况下，如果控制台中有多条 sql，会提示你要执行哪条 sql。之前习惯了 dbvisualizer 中的操作，dbvisualizer 中光标停留在当前 sql上(sql以分号结尾)，按下 Ctrl + . 快捷键会自动执行当前 sql， 其实 DataGrip 也能设置，在 setting->Database-General 中 语句执行时默认是提示，改成 smallest statement 后，光标停留在当前语句时，按下 Ctrl + Enter 就会直接执行当前语句。 语句的执行结果在底部显示 如果某列的宽度太窄，可以鼠标点击该列的任意一个，使用快捷键 Ctrl + Shift + 左右箭头 可以调整宽度，如果要调整所有列的宽度，可以点击左上角红框部分，选择所有行，使用快捷键 Ctrl + Shift + 左右箭头 调整 添加行、删除行也很方便，上部的 +、- 按钮能直接添加行或删除选中的行，编辑列同样也很方便，双击要修改的列，输入修改后的值，鼠标在其他部分点击就完成修改了，改完之后记得提交才生效（快捷键：Ctrl + Enter）。 有的时候我们要把某个字段置为 null，不是空字符串，DataGrip 也提供了渐变的操作，直接在列上右键，选择 set null 对于需要多窗口查看结果的，即希望查询结果在新的 tab 中展示，可以点击 pin tab 按钮，那新查询将不会再当前 tab 中展示，而是新打开一个 tab 旁边的 output 控制台显示了执行 sql 的日志信息，能看到 sql 执行的时间等信息 我就问这么吊的工具，还有谁！！！ 要新建表也是相当简单、智能，选中数据库连接，点击绿色 + 号下选择 table 在新打开的窗口中，可以填写表信息 我就问你看到这个窗口兴奋不兴奋！！！ 顶部可以填写表名、表注释，中间可以点击右侧绿色 + 号添加列，列类型 type 也是能自动补全，default 右侧的消息框图标点击后能对列添加注释，旁边的几个 tab 可以设置索引及外键 所有这些操作的 DDL 都会直接在底部显示 我就问你怕不怕 表建完后，可以点击下图中的 table 图标，打开表查看视图 可以查看表的数据，也能查看 DDL 语句 这些基本功能的设计、体验，已经惊艳到我了，接下来就是数据的导出。 DataGrip 的导出功能也是相当强大 选择需要导出数据的表，右键，Dump Data To File 即可以导出 insert、update 形式的 sql 语句，也能导出为 html、csv、json 格式的数据 也可以在查询结果视图中导出 点击右上角下载图标，在弹出窗口中可以选择不同的导出方式，如 sql insert、sql update、csv 格式等 如果是导出到 csv 格式，还能控制导出的格式 导出后用 excel 打开是这种结果 除了能导出数据外，还能导入数据 选择表，右键->Import from File，选择要导入的文件 注意，导出的时候如果勾选了左侧的两个 header 选项，导入的时候如果有 header，也要勾选，不然会提示列个数不匹配 1、关键字导航： 当在 datagrip 的文本编辑区域编写 sql 时，按住键盘 Ctrl 键不放，同时鼠标移动到 sql 关键字上，比如表名、字段名称、或者是函数名上，鼠标会变成手型，关键字会变蓝，并加了下划线，点击，会自动定位到左侧对象树，并选中点击的对象 2、快速导航到指定的表、视图、函数等： 在 datagrip 中，使用 Ctrl + N 快捷键，弹出一个搜索框，输入需要导航的名称，回车即可 3、全局搜索 连续两次按下 shift 键，或者鼠标点击右上角的搜索图标，弹出搜索框，搜索任何你想搜索的东西 4、结果集搜索 在查询结果集视图区域点击鼠标，按下 Ctrl + F 快捷键，弹出搜索框，输入搜索内容，支持正则表达式、过滤结果 5、导航到关联数据 表之间会有外检关联，查询的时候，能直接定位到关联数据，或者被关联数据，例如 user1 表有个外检字段 classroom 指向 classroom 表的主键 id，在查询 classroom 表数据的时候，可以在 id 字段上右键，go to，referencing data 选择要显示第一条数据还是显示所有数据 会自动打开关联表的数据 相反，查询字表的数据时，也能自动定位到父表 6、结果集数据过滤 对于使用 table edit（对象树中选中表，右键->table editor）打开的结果集，可以使用条件继续过滤结果集，如下图所示，可以在结果集左上角输入款中输入 where 条件过滤 也可以对着需要过滤数据的列右键，filter by 过滤 7、行转列 对于字段比较多的表，查看数据要左右推动，可以切换成列显示，在结果集视图区域使用 Ctrl + Q 快捷键 1、变量重命名 鼠标点击需要重命名的变量，按下 Shift + F6 快捷键，弹出重命名对话框，输入新的名称 2、自动检测无法解析的对象 如果表名、字段名不存在，datagrip 会自动提示，此时对着有问题的表名或字段名，按下 Alt + Enter，会自动提示是否创建表或添加字段 3、权限定字段名 对于查询使用表别名的，而字段中没有使用别名前缀的，datagrip 能自动添加前缀，鼠标停留在需要添加别名前缀的字段上，使用 Alt + Enter 快捷键 4、通配符自动展开 查询的时候我们会使用 select * 查询所有列，这是不好的习惯，datagrip 能快速展开列，光标定位到 * 后面，按下 Alt + Enter 快捷键 5、大写自动转换 sql 使用大写形式是个好的习惯，如果使用了小写，可以将光标停留在需要转换的字段或表名上，使用 Ctrl + shift + U 快捷键自动转换 6、sql格式化 选中需要格式化的 sql 代码，使用 Ctrl + Alt + L 快捷键 datagrip 提供了一个功能强大的编辑器，实现了 notpad++ 的列编辑模式 1、多光标模式 在编辑 sql 的时候，可能需要同时输入或同时删除一些字符，按下 alt + shift，同时鼠标在不同的位置点击，会出现多个光标 2、代码注释 选中要注释的代码，按下 Ctrl+/ 或 Ctrl + shift + / 快捷键，能注释代码，或取消注释 3、列编辑 按住键盘 Alt 键，同时按下鼠标左键拖动，能选择多列，拷贝黏贴等操作 4、代码历史 在文本编辑器中，邮件，local history，show history，可以查看使用过的 sql 历史 命令历史 "},"tools/navicat/navicat.html":{"url":"tools/navicat/navicat.html","title":"Navicat","keywords":"","body":"Navicat 操作手册地址：https://www.navicat.com.cn/manual/online_manual/cn/navicat/win_manual/ Navicat 快捷键 常规 键 动作 CTRL + SHIFT + #（# 代表 1 至 9） 添加到收藏夹 F8 Navicat 主窗口或对象选项卡 CTRL + TAB 或 SHIFT+CTRL+TAB 下一个窗口或选项卡 CTRL + Q 新建查询 F1 帮助 Navicat 主窗口 键 动作 CTRL + G 打开设置位置的文件夹 CTRL + #（# 代表 1 至 9） 打开收藏夹链接 F6 命令列界面 CTRL + L 历史日志 F12 仅显示活跃对象 CTRL + N 新建对象 CTRL + SHIFT + F 在数据库或模式中查找 ER 图表视图 键 动作 F5 刷新 ESC 选择 H 移动图表 R 新建外键 DELETE 删除已选择的外键 CTRL + = 或 CTRL + 滑鼠滚轮向上 放大 CTRL + - 或 CTRL + 滑鼠滚轮向下 缩小 CTRL + 0 重置缩放 表或集合设计器 键 动作 CTRL + O 打开表或集合 CTRL + F 查找字段 F3 查找下一个字段 SHIFT + F3 查找上一个字段 数据查看器 键 动作 CTRL + D 设计对象（表、集合、视图、实体化视图） CTRL + Q 查询对象（表、集合、视图、实体化视图） CTRL + F 查找文本 F3 查找下一个文本 CTRL + G 前往行 CTRL + LEFT ARROW 移动到当前记录的第一列 CTRL + RIGHT ARROW 移动到当前记录的最后一列 CTRL + HOME 移动到当前列的第一行 CTRL + END 移动到当前列的最后一行 CTRL + PAGE UP 或 CTRL + UP ARROW 移动到当前页面的第一行 CTRL + PAGE DOWN 或 CTRL + DOWN ARROW 移动到当前页面的最后一行 CTRL + R 应用筛选或应用排序 SHIFT + ARROW 选择单元格 CTRL + ENTER 打开编辑器来编辑数据 INSERT or CTRL + N 添加记录 CTRL + DELETE 删除记录 CTRL + S 应用记录更改 ESC 放弃记录更改 CTRL + T 停止加载数据 视图或实体化视图设计器 键 动作 CTRL + O 导入 SQL CTRL + E 切换到定义 CTRL + R 预览 ALT + #（# 代表 1 至 9） 切换到结果 1 - 9 查询设计器 键 动作 CTRL + O 打开外部文件 CTRL + E 切换到查询编辑器 CTRL + R 运行或运行已选择的 CTRL + SHIFT + R 运行当前语句 CTRL + T 停止 ALT + #（# 代表 0 至 9） 切换到结果选项卡 查询编辑器 键 动作 CTRL + SHIFT + V 从剪贴板堆栈粘贴 CTRL + / 注释或取消注释行 CTRL + F 查找文本 F3 查找下一个文本 CTRL + = 放大 CTRL + - 缩小 CTRL + 0 重置缩放 SQL 创建工具 键 动作 CTRL + = 放大 CTRL + - 缩小 CTRL + 0 重置缩放 调试器 键 动作 F9 运行 F10 逐过程 F11 逐语句 SHIFT + F11 跳过 模型 键 动作 CTRL + D 在模型新建图表 CTRL + P 打印图表 ESC 选择 H 移动图表 T 新建表或实体 V 新建视图 R 新建外键或关系 A 新建标签 N 新建笔记 I 新建图像 L 新建层 CTRL + B 设置已选择的表、实体、视图、外键或形状为粗体 CTRL + = 或 CTRL + 滑鼠滚轮向上 放大 CTRL + - 或 CTRL + 滑鼠滚轮向下 缩小 CTRL + 0 重置缩放 图表 键 动作 CTRL + D 设计对象 F5 刷新数据 F11 显示仪表板 CTRL + P 打印仪表板 "},"tools/sublime/sublime.html":{"url":"tools/sublime/sublime.html","title":"Sublime","keywords":"","body":"1. 前言 Sublime Text 支持多种编程语言的 语法高亮、拥有优秀的代码自动完成功能，还拥有代码片段（Snippet）的功能，可以将常用的代码片段保存起来，在需要时随时调用。支持 VIM 模式，可以使用Vim模式下的多数命令。支持宏，简单地说就是把操作录制下来或者自己编写命令，然后播放刚才录制的操作或者命令。 Sublime Text 还具有良好的扩展能力和完全开放的用户自定义配置与神奇实用的编辑状态恢复功能。支持强大的多行选择和多行编辑。强大的快捷命令“可以实时搜索到相应的命令、选项、snippet 和 syntex， 按下回车就可以直接执行，减少了查找的麻烦。即时的文件切换。随心所欲的跳转到任意文件的任意位置。多重选择功能允许在页面中同时存在多个光标。 回到顶部 2. Sublime 快捷键 2.1 选择类 快捷键 介绍 Ctrl + D 选中光标所占的文本，继续操作则会选中下一个相同的文本。 Ctrl + L 选中整行，继续操作则继续选择下一行，效果和 Shift + ↓ 效果一样。 Ctrl + M 光标移动至括号内结束或开始的位置。 Ctrl + Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。 Ctrl + [ 减少缩进。 Ctrl + ] 增加缩进。 Ctrl + ← 向左单位性地移动光标，快速移动光标。 Ctrl + → 向右单位性地移动光标，快速移动光标。 Ctrl + K + 0 展开所有折叠代码。 Ctrl + Shift + A 如果你把光标放在文本间再按下上面的键将选择文本，就像 Ctrl + D。但是再次按下它，将选择父容器，再按，将选择父容器的父容器。 Ctrl + Shift + L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 Ctrl + Shift + M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。 Ctrl + Shift + Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。 Ctrl + Shift + [ 选中代码，按下快捷键，折叠代码。 Ctrl + Shift + ] 选中代码，按下快捷键，展开代码。 Ctrl + Shift + ← 向左单位性地选中文本。 Ctrl + Shift + → 向右单位性地选中文本。 Ctrl + Shift + ↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。 Ctrl + Shift + ↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。 Ctrl + Alt + ↑ 向上添加多行光标，可同时编辑多行。 Ctrl + Alt + ↓ 向下添加多行光标，可同时编辑多行。 Shift + ↑ 向上选中多行。 Shift + ↓ 向下选中多行。 Shift + ← 向左选中文本。 Shift + → 向右选中文本。 Alt + F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。 2.2 编辑类 快捷键 介绍 Tab 向右缩进。 Ctrl + J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。 Ctrl + T 左右字母互换。 Ctrl + U 软撤销，感觉和 Gtrl + Z 一样。 Ctrl + Y 恢复撤销。 Ctrl + Z 撤销。 Ctrl + / 注释单行。 Ctrl + F2 设置书签 Ctrl + Shift + D 复制光标所在整行，插入到下一行。 Ctrl + K + K 从光标处开始删除代码至行尾。 Ctrl + Shift + K 删除整行。 Ctrl + Shift + / 注释多行。 Ctrl + K + U 转换大写。 Ctrl + K + L 转换小写。 F6 单词检测拼写 Shift + Tab 向左缩进。 Alt + Shift + W 用标签包裹行或选中项 2.3 搜索类 快捷键 介绍 Ctrl + F 打开底部搜索框，查找关键字。 Ctrl + G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。 Ctrl + P 打开搜索框。举个栗子： 1、输入当前项目中的文件名，快速搜索文件； 2、输入@和关键字，查找文件中函数名； 3、输入：和数字，跳转到文件中该行代码； 4、输入#和关键字，查找变量名。 Ctrl + R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。 Ctrl + ： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 Ctrl + shift + F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。 Ctrl + Shift + P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 2.4 显示类 快捷键 介绍 Ctrl + Tab 按文件浏览过的顺序，切换当前窗口的标签页。 Ctrl + PageDown 向左切换当前窗口的标签页。 Ctrl + PageUp 向右切换当前窗口的标签页。 Ctrl + K + B 开启/关闭侧边栏。 Shift + F11 免打扰模式 Alt + Shift + 1 窗口分屏，恢复默认1屏（非小键盘的数字） Alt + Shift + 2 左右分屏-2列 Alt + Shift + 3 左右分屏-3列 Alt + Shift + 4 左右分屏-4列 Alt + Shift + 5 等分4屏 Alt + Shift + 8 垂直分屏-2屏 Alt + Shift + 9 垂直分屏-3屏 F11 全屏模式 "},"tools/chrome/chrome.html":{"url":"tools/chrome/chrome.html","title":"Chrome","keywords":"","body":"使用双引号精确搜索 在需要搜索的关键词上加上双引号，搜索引擎就会返回和关键词吻合的搜索结果。通常 Google 搜索的关键词可以是词组（中间没有空格），也可以是句子，但是用句子做关键词，就必须加英文引号，否则会被拆分成几个词组进行检索 例如：\"what is css\" 使用 - 操作符排除关键词 如果你不想搜索到某个内容，可以在搜索关键词后面使用 - 操作符对指定内容进行排除。 例如：输入\"LeanCloud\"-百度百科，即可搜索包含 LeanCloud 内容，但排除来源于百度百科的信息。 .. 搜索数字范围 如果你只想查询某个数字范围的内容，可以在数字之间使用 .. 进行限制，更精准的找到你需要的内容。如 10..35 斤、300..500 元 等。 例如：搜索框输入 JavaScript 2019..2021 年，就可以查找 2019 年至 2021 年之间关于 JavaScript 的内容。 * 通配符或未知字词 * 号是一个通配符，可以替代任何单词或者短语。如果你想查找一首歌的歌词，但记不起具体的歌词时这个方法很有用。 示例：穿新衣吧剪新发型啊*Windows98 用 OR（或）逻辑进行搜索 示例：搜索包含 python 或者 html css，或者两者均有的中英文网站。 使用 AND 操作符 可以搜索包含两个关键词的搜索结果。 示例：html AND css 针对文件类型搜索 如果你只想查找 PDF 文件、Word 文档、或 EXCEL 表格，就可以使用 filetype: 操作符，支持的格式还有 ps 、dwf 、kml/kmz、ppt、rtf、swf 等。 示例：filetype:pdf learn python 站内搜索 在输入框输入 site:+ 网址 + 关键词，可以直接搜索出网站内与关键词相关的内容。 示例：site:leancloud.cn 即时通讯 快速搜索 查单词含义，例如 define:BaaS 查找域名相关的站点，例如 related:apple.com 查找内容包含某个关键词的页面，例如 intex:leancloud "},"tools/github/github.html":{"url":"tools/github/github.html","title":"Github","keywords":"","body":"一个快速在编辑器中打开 Github 仓库源码的小技巧。只需将 github 域名的 com 改为 dev 或者在 github 域名后面添加一个1s，即可在 Web 端的 VS Code 中打开源码! 例如，对于：https://github.com/facebook/react ，改成以下任意一种即可： https://github1s.com/facebook/react https://github.dev/facebook/react "},"tools/fleet/fleet.html":{"url":"tools/fleet/fleet.html","title":"Fleet","keywords":"","body":"切换主题 按下 Ctrl + ` 可切换主题。 工具和面板 可以使用窗口左上角的按钮或按 Alt + 1、Alt + 2 或来打开工具面板 Alt + 3。 处理文件和文件夹 Ctrl + N 创建文件。 编辑文本 拆分视图 请将选项卡拖动到编辑器一侧（用于垂直拆分）或编辑器顶部或底部（用于水平拆分）。 多个插入符号 您可以使用额外的插入符号同时在多个位置更改文本。要创建其他插入符号，请执行以下操作之一： 按 Ctrl + Shift + ↑ 或 Ctrl + Shift + ↓ 分别在当前插入符号的上方或下方添加插入符号。 按住 Alt + Shift 并单击要添加插入符号的位置。 使用多个插入符号，您不仅可以打字：您可以复制、粘贴、自动完成单词等等。 扩大和缩小选择 您可以根据文本或代码结构在插入符号处扩展和缩小选择。使用Alt + ↑和Alt + ↓。 格式化代码（Ctrl + Alt + L） 打开设置（Ctrl + Alt + S） 搜索 每当您想要执行全文搜索、导航到某个课程或只是不记得如何在 Fleet 中执行某些操作时，Go to 对话框都是正确的工具。 按 Ctrl + K 并使用 选择所需的选项卡 Ctrl + Tab。 版本控制 打开终端 Ctrl + Alt + T 并运行以下命令： git init echo \"Hello\" > greeting git add . git commit -m \"first commit\" 这将在工作区中初始化一个 Git 存储库，创建一个文本文件，并将整个工作区添加到版本控制中。您可以省略此步骤并改用您自己的支持 Git 的项目。 对文本文件进行一些更改： 编辑文本文件 一个蓝色圆圈出现在该文件附近的“文件”视图中，表示存在未提交的更改。 在 Files 视图中，转到 Git 选项卡，确保选择了更改，然后单击 Commit。 转到弹出窗口（Ctrl + K） Goto 弹出窗口是项目中与搜索相关的所有内容的中心位置。您可以使用快捷方式或单击 JetBrains Fleet 窗口右上角的搜索图标来访问它。 Goto弹出窗口可帮助您查找文件、操作、符号等。记住它的快捷方式将为您节省大量时间。 默认情况下，它会搜索文件和顶级符号。您还可以将搜索范围缩小到文件 Ctrl + P、符号 Ctrl + Shift + P 或当前文件中的符号 Ctrl + Shift + O。 操作 Ctrl + Shift + K、工具和全文搜索 Ctrl + Shift + F 在 Goto 弹出窗口中作为选项卡提供。您可以从转到选项卡切换到它们，Ctrl + Tab 或者使用专用快捷方式立即打开所需的选项卡。 如果您需要更多空间来显示结果，可以将搜索移至专用面板。为此，请单击弹出窗口右上角的“在选项卡中打开”图标。 全文搜索（Ctrl + Shift + F） 如果您需要在整个项目中搜索文件内容或自动替换它，请使用文本搜索对话框。对于高级查询，它有几个匹配选项并允许您使用正则表达式。 找到所需位置后，您可以在单独的编辑器选项卡中打开它，也可以直接从预览中编辑它。 要切换替换模式，请单击搜索字段右侧的替换： 如果您需要更多空间来显示结果，可以将搜索移至专用面板。为此，请单击弹出窗口右上角的“在选项卡中打开”图标。 浏览文件结构（Ctrl + Shift + O） 您可以使用 Goto 弹出窗口快速查看文件结构并导航到其中一个元素。文件元素以树状结构显示。 编辑器导航 以下操作将帮助您以有效的方式在编辑器选项卡和文件位置之间导航： 动作名称 捷径 描述 后退 Ctrl + Alt + ← 导航到最近访问过的位置并返回 向前 Ctrl + Alt + → 上一个标签 Ctrl + PgUp 在编辑器选项卡之间切换 下一个标签 Ctrl + PgDn 在编辑器选项卡之间切换 转到上一个错误 Ctrl + Shift + E 在当前文件中的错误和警告之间导航（可能需要智能模式） 转到下一个错误 Ctrl + E 去线 Ctrl + L 导航到当前文件中的特定行 寻找 Ctrl + F 在当前文件中搜索和替换 代替 Ctrl + Alt + F 智能模式 您可以将 JetBrains Fleet 用作智能文本编辑器，而不是完整的 IDE。但是，如果您需要代码智能功能，您可以通过打开智能模式来启用它们。 特征 以下功能需要智能模式： 语义突出显示（部分可用，无需智能模式） 代码完成（部分可用，无需智能模式） 代码重构 导航和搜索（部分可用，无需智能模式） 查找用法 参数和表达式的类型信息检索 安全 为了使 Fleet 的智能模式功能正常工作，它可能需要执行项目代码，这可能会在其来源不受信任时造成问题。导入项目、运行脚本和执行 git 命令等操作可能会运行恶意代码。因此，只有在您信任代码作者时才启用智能模式很重要。 快速修复和意图操作 按下 Alt + Enter 可访问 Fleet 在当前上下文中建议的操作。 重构代码 将插入符号放在文字上或选择一个表达式，然后按 Ctrl + Alt + V。 浏览代码库 使用导航到符号的声明 Ctrl + B。 使用嵌体提示导航到用法和层次结构成员。 Ctrl + E 使用和浏览错误 Ctrl + Shift + E。 使用实时模板 要生成 for 循环，请键入 fori 并按 Tab。Tab 填写必要的变量时按。 代码完成（Ctrl + Space） 在您键入时，JetBrains Fleet 会建议完成选项。这些建议基于许多因素，例如可用的代码智能服务、项目模型、周围代码和符号的可见性。 代码操作 JetBrains Fleet 不断分析您的代码并建议您可能希望在当前上下文中执行的操作。建议的操作范围从纠正错误到在插入符号处重构代码。 要查看插入符号处可用的操作，请按 Alt + Enter。选择所需的操作后，您可以立即应用它或使用 预览结果Ctrl + P。 类型信息 当您不确定当前使用的是什么类型时，您可以按 查找它Ctrl + Alt + Shift + I。JetBrains Fleet 将在插入符号处显示符号或表达式的静态类型信息。 参数信息 如果您正在使用具有大量重载的方法，或者只是想查找所需的参数，请使用Ctrl + I. 实时模板 使用实时模板将常见结构插入到您的代码中，例如循环、条件、声明或打印语句。 要展开代码片段，请输入相应的模板缩写并按 ⇥。按住 ⇥ 以从模板中的一个变量跳转到下一个变量。按 ⇧⇥ 移动到上一个变量。 代码生成 使用代码完成来覆盖超类成员、生成访问器方法、、equals()等等hashcode()。 例如，如果您想为名为的字段生成 getter number，请键入 gn 并 getNumber() 从建议中进行选择。 换行时缩进 每当您放置换行符时，JetBrains Fleet 都会以正确的缩进开始新行。默认情况下启用此功能。 禁用自动缩进 在首选项菜单中，取消选中编辑器：代码 | Enter 上的自动缩进。 或者，将以下行添加到您的 settings.json 文件中： \"enableIndenter\": false 设置工作区 工作区是您的项目所在的目录。它包含项目文件和设置。您可以通过打开一个空目录来打开现有项目或启动新项目。 打开工作区 按 Ctrl + O 或选择文件 | 从菜单中打开。 2, 在文件浏览器中，导航到要存储代码的空文件夹，然后单击 Open。 当您打开一个目录时，它会成为一个工作空间的根。您可以在文件视图中查看其内容。 实时模板列表 "},"utilities/windows/windows.html":{"url":"utilities/windows/windows.html","title":"Windows","keywords":"","body":""},"utilities/mac/mac.html":{"url":"utilities/mac/mac.html","title":"Mac","keywords":"","body":""},"utilities/hacker/hacker.html":{"url":"utilities/hacker/hacker.html","title":"黑客","keywords":"","body":"Resource Hacker 下载地址 Resource Hacker™ 是 32 位和 64 位 Windows® 应用程序的资源编辑器。它既是一个资源编译器（针对 *.rc 文件），也是一个反编译器， 可以查看和编辑可执行文件（*.exe、*.dll、*.scr 等）和已编译资源库（*.res、*.mui). 虽然 Resource Hacker™ 主要是一 个 GUI 应用程序，但它也提供了许多用于从命令行编译和反编译资源的选项。 1. 对象 网站：源码 robots文件 后台登录 服务器：IP地址 服务器操作系统类型和版本 端口开放情况 管理员：个人信息 手机号 社交账号 常用密码 敏感数字 2. 网站操作类型识别方式 windows：不区分大小写 Linux：区分大小写 3. 网站指纹识别工具 御剑指纹识别 云悉在线指纹识别 kali——whatweb 火狐浏览器插件——Wappalyzer 4. 目录扫描 / 敏感文件扫描 搜索网站目录下面的敏感文件 间接识别网站使用的框架或者内容管理系统 工具：御剑指纹识别 谷歌黑客语法 site：限制搜索范围的域名 inurl：限制搜索的url中必须存在的内容 intext：限制搜索的页面中必须存在的内容 intitle：限制搜索的页面的标题栏中的内容 filetype：限制搜索的文件类型 5. IP 查询 命令：ping nslookup 工具：站长之家 ip138 6. 端口扫描 nmap 御剑端口扫描 shell、python脚本 7. whois 查询 站长工具 ip138 中国万网 爱站网 8. 子域名查询 查询方式：枚举(暴力破解) 工具：子域名挖掘机 9. 空间搜索引擎 shadon 钟馗之眼 fofa 10. 常见端口 21：文件传输 FTP 22：SSH 23：Telnet 25：电子邮件 53：DNS 67：DHCP 110：POP3 135：RPC 139：NetBIOS 443：HTTPS 445：SMB协议 3306：MySQL 3389：远程桌面 1521：Orale 1433：sql server "},"architect/computer_composition_and_architecture.html":{"url":"architect/computer_composition_and_architecture.html","title":"计算机组成与体系结构","keywords":"","body":"计算机组成与体系结构 计算机组成结构 计算机系统是一个硬件和软件的综合体，原始的冯•诺依曼（Von Neumann）计算机在结构上是以运算器为中心的，而发展到现在，已转向以存储器为中心了，下图是计算机最基本的组成图： CPU 组成 CPU 的内核分为运算器和控制器 运算器 算术逻辑单元 ALU：数据的算术运算和逻辑运算 累加寄存器 AC：通用寄存器，为ALU提供一个工作区，用于暂存数据 数据缓冲寄存器 DR：写内存时，暂存指令或数据 状态寄存器 PSW：存状态标志与控制标志（争议：也有将其归为控制器） 控制器 程序计数器 PC：存储下一条要执行指令的地址 指令寄存器 IR：存储即将执行的指令 指令译码器 ID：对指令中的操作码字段进行分析解析 时序部件：提供时序控制信号 计算机执行程序时，在一个指令周期的过程中，为了能够从内存中读指令操作码，首先是将( A )的内容送到地址总线上。 A 程序计数器 PCB 指令寄存器 IRC 状态寄存器 SRD 通用寄存器 GR 冯诺依曼结构 冯诺依曼结构也称普林斯顿结构，是一种将程序指令存储器和数据存储器合并在一起的存储器结构。 冯诺依曼结构的特点： 一般用于 PC 处理器，如i3，i5，i7处理器； 指令与数据存储器合并在一起； 指令与数据都通过相同的数据总线传输。 哈佛结构 哈佛结构是一种将程序指令存储和数据存储分开的存储器结构。哈佛结构是一种并行体系结构，它的主要特点是将程序和数据存储在不同的存储空间内，即程序存储器和数据存储器是两个独立的存储器，每个存储器独立编址、独立访问。 哈佛结构的特点： 一般用于嵌入式系统处理器（DSP）数字信号处理（DSP，Digital Signal Processing） 指令与数据分开存储，可以并行读取，有较高的数据吞吐率 有四条总线：指令和数据的数据总线与地址总线 芯片 DSP DSP 芯片，也称数字信号处理器，是一种特别适合与进行数字信号处理运算的微处理器，其主要应用是实时快速地实现各种数字信号处理算法。 SoC System on Chip，简称 Soc，也即片上系统。从狭义角度讲，它是信息系统核心的芯片集成，是将系统关键部件集成在一块芯片上；从广义角度讲，SoC 是一个微小型系统，如果说中央处理器（CPU）是大脑，那么 SoC 是大脑，那么 SoC 就是包括大脑、心脏、眼睛和手的系统。 MPU 微机中的中央处理器（CPU）称为微处理器（MPU），是构成微机的核心部件，也可以说是微机的心脏。它起到控制整个微型计算机工作的作用，产生控制信号对相应的部件进行控制，并执行相应的操作。 MCU 微控制单元（Microcontroller Unit：MCU），又称单片微型计算机（Single Chip Microcomputer）或者单片机，是把中央处理器（Central Process Unit：CPU）的频率与规格做适当缩减，并将内存（memory）、计数器（Timer）、USB、A/D转换、UART、PLC、DMA等周边接口，甚至LCD驱动电路都整合在单一芯片上，形成芯片级的计算机，为不同的应用场合做不同组合控制。 目前处理器市场中存在 CPU 和 DSP 两种类型处理器，分别用于不同场景，这两种处理器具有不同的体系结构，DSP 采用( B )。 A 冯·诺伊曼结构B 哈佛结构C FPGA 结构D 与 GPU 相同结构 嵌入式处理器是嵌入式系统的核心部件，一般可分为嵌入式微处理器(MPU)、微控制器(MCU)、数字信号处理器(DSP)和片上系统(SoC)。以下叙述中，错误的是（ A ）。 A MPU 在安全性和可靠性等方面进行增强，适用于运算量较大的智能系统B MCU 典型代表是单片机,体积小从而使功耗和成本下降C DSP 处理器对系统结构和指令进行了特殊设计,适合数字信号处理D SoC 是一个有专用目标的集成电路，其中包括完整系统并有嵌入式软件的全部内容 存储系统 计算机存储结构上图所示，总结如下：（速度由高到低排序，容量由低到高排序，成本由高到低排序） CPU 寄存器：速度最快，容量最小，成本高 Cache：按内容存取 内存（主存）：随机存储器（RAM）只读存储器（ROM） 外存（辅存）：硬盘、光盘、U盘等 计算机采用分级存储体系的主要目的是为了（ D ）。 A 解决主存容量不足的问题B 提高存储器读写可靠性C 提高外设访问效率D 解决存储的容量、价格和速度之间的矛盾 Cache Cache 的功能：提高 CPU 数据输入输出的速率，突破冯诺依曼瓶颈（CPU 与存储系统间数据传输宽带限制）； 在计算器的存储体系中，Cache 是访问速度最快的层次（不存在 CPU 寄存器的情况下）； Cache 对程序员来说是透明的； 使用 Cache 改善系统性能的依据是程序的局部性原理（时间和空间局部性）。 时间局部性：指程序中的某条执行一旦执行，不久以后该指令可能再次执行，典型原因是由于程序中存在着大量的循环操作。 空间局部性：指一旦程序访问了某个存储单元，不久以后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址可能集中在一定的范围内，其典型情况是程序顺序执行。 工作集理论：工作集是进程运行时被频繁访问的页面集合。 在嵌入式系统设计时，下面几种存储结构中对程序员是透明的是( A ）。 A 高速缓存 B 磁盘存储器 C 内存 D flash 存储器 如何计算系统获取缓存的平均周期 t3 ，如果使用 h 代表 Cache 的访问命中率，t1 表示 Cache 的周期时间，t3 表示主存周期时间，以读操作为例，算法如下： t3 = h * t1 + (1 - h) * t2 其中，(1 - h)又称为失效率（未命中率）。 存储管理 数据传输控制方式 总线 CISC 与 RISC 流水线 校验码 "}}