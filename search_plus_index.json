{"./":{"url":"./","title":"介绍","keywords":"","body":"notes sdf xxxx "},"java/java.html":{"url":"java/java.html","title":"JAVA","keywords":"","body":"hello java System.out.println(\"hello java\"); System.out.println(\"hello java\"); System.out.println(\"hello java\"); "},"java/sql.html":{"url":"java/sql.html","title":"SQL语法","keywords":"","body":"1. 基本概念 1.1 数据库术语 数据库（database） - 保存有组织的数据的容器（通常是一个文件或一组文件）。 数据表（table） - 某种特定类型数据的结构化清单。 模式（schema） - 关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。 列（column） - 表中的一个字段。所有表都是由一个或多个列组成的。 行（row） - 表中的一个记录。 主键（primary key） - 一列（或一组列），其值能够唯一标识表中每一行。 1.2 SQL 语法 SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。 1.2.1 SQL 语法结构 SQL 语法结构包括： 子句 - 是语句和查询的组成成分。（在某些情况下，这些都是可选的。） 表达式 - 可以产生任何标量值，或由列和行的数据库表 谓词 - 给需要评估的 SQL 三值逻辑（3VL）（true/false/unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。 查询 - 基于特定条件检索数据。这是 SQL 的一个重要组成部分。 语句 - 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。 1.2.2 SQL 语法要点 SQL 语句不区分大小写，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。 例如：SELECT 与 select、Select 是相同的。 多条 SQL 语句必须以分号（;）分隔。 处理 SQL 语句时，所有空格都被忽略。SQL 语句可以写成一行，也可以分写为多行。 ## 一行 SQL 语句 UPDATE user SET username='robot', password='robot' WHERE username = 'root'; ## 多行 SQL 语句 UPDATE user SET username='robot', password='robot' WHERE username = 'root'; SQL 支持三种注释## 注释1 -- 注释2 /* 注释3 */ 1.3 SQL 分类 1.3.1 数据定义语言（DDL） 数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。 DDL 的主要功能是定义数据库对象。 DDL 的核心指令是 CREATE、ALTER、DROP。 1.3.2 数据操纵语言（DML） 数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。 DML 的主要功能是访问数据，因此其语法都是以读写数据库为主。 DML 的核心指令是 INSERT、UPDATE、DELETE、SELECT。这四个指令合称 CRUD(Create, Read, Update, Delete)，即增删改查。 1.3.3 事务控制语言（TCL） 事务控制语言 (Transaction Control Language, TCL) 用于管理数据库中的事务。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。 TCL 的核心指令是 COMMIT、ROLLBACK。 1.3.4 数据控制语言（DCL） 数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。 DCL 的核心指令是 GRANT、REVOKE。 DCL 以控制用户的访问权限为主，因此其指令作法并不复杂，可利用 DCL 控制的权限有：CONNECT、SELECT、INSERT、UPDATE、DELETE、EXECUTE、USAGE、REFERENCES。 根据不同的 DBMS 以及不同的安全性实体，其支持的权限控制也有所不同。 2. 增删改查 增删改查，又称为 CRUD，数据库基本操作中的基本操作。 2.1 插入数据 INSERT INTO 语句用于向表中插入新记录。 插入完整的行 INSERT INTO user VALUES (10, 'root', 'root', 'xxxx@163.com'); 插入行的一部分 INSERT INTO user(username, password, email) VALUES ('admin', 'admin', 'xxxx@163.com'); 插入查询出来的数据 INSERT INTO user(username) SELECT name FROM account; 2.2 更新数据 UPDATE 语句用于更新表中的记录。 UPDATE user SET username='robot', password='robot' WHERE username = 'root'; 2.3 删除数据 DELETE 语句用于删除表中的记录。 TRUNCATE TABLE 可以清空表，也就是删除所有行。 删除表中的指定数据 DELETE FROM user WHERE username = 'robot'; 清空表中的数据 TRUNCATE TABLE user; 2.4 查询数据 SELECT 语句用于从数据库中查询数据。 DISTINCT 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。 LIMIT 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。 ASC ：升序（默认） DESC ：降序 查询单列 SELECT prod_name FROM products; 查询多列 SELECT prod_id, prod_name, prod_price FROM products; 查询所有列 ELECT * FROM products; 查询不同的值 SELECT DISTINCT vend_id FROM products; 限制查询结果 -- 返回前 5 行 SELECT * FROM mytable LIMIT 5; SELECT * FROM mytable LIMIT 0, 5; -- 返回第 3 ~ 5 行 SELECT * FROM mytable LIMIT 2, 3 LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)。 3. 子查询 子查询是嵌套在较大查询中的 SQL 查询。子查询也称为内部查询或内部选择，而包含子查询的语句也称为外部查询或外部选择。 子查询可以嵌套在 SELECT，INSERT，UPDATE 或 DELETE 语句内或另一个子查询中。 子查询通常会在另一个 SELECT 语句的 WHERE 子句中添加。 您可以使用比较运算符，如 >，，或 =。比较运算符也可以是多行运算符，如 IN，ANY 或 ALL。 子查询必须被圆括号 () 括起来。 内部查询首先在其父查询之前执行，以便可以将内部查询的结果传递给外部查询。执行过程可以参考下图： 3.1 子查询的子查询 SELECT cust_name, cust_contact FROM customers WHERE cust_id IN (SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = 'RGAN01')); 3.2 WHERE WHERE 子句用于过滤记录，即缩小访问数据的范围。 WHERE 后跟一个返回 true 或 false 的条件。 WHERE 可以与 SELECT，UPDATE 和 DELETE 一起使用。 可以在 WHERE 子句中使用的操作符 运算符 描述 = 等于 <> 不等于。注释：在 SQL 的一些版本中，该操作符可被写成 != > 大于 小于 >= 大于等于 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 IN 指定针对某个列的多个可能值 SELECT 语句中的 WHERE 子句 SELECT * FROM Customers WHERE cust_name = 'Kids Place'; UPDATE 语句中的 WHERE 子句 UPDATE Customers SET cust_name = 'Jack Jones' WHERE cust_name = 'Kids Place'; DELETE 语句中的 WHERE 子句 DELETE FROM Customers WHERE cust_name = 'Kids Place'; 3.3 IN 和 BETWEEN IN 操作符在 WHERE 子句中使用，作用是在指定的几个特定值中任选一个值。 BETWEEN 操作符在 WHERE 子句中使用，作用是选取介于某个范围内的值。 IN 示例 SELECT * FROM products WHERE vend_id IN ('DLL01', 'BRS01'); BETWEEN 示例 SELECT * FROM products WHERE prod_price BETWEEN 3 AND 5; 3.4 AND、OR、NOT AND、OR、NOT 是用于对过滤条件的逻辑处理指令。 AND 优先级高于 OR，为了明确处理顺序，可以使用 ()。 AND 操作符表示左右条件都要满足。 OR 操作符表示左右条件满足任意一个即可。 NOT 操作符用于否定一个条件。 AND 示例 SELECT prod_id, prod_name, prod_price FROM products WHERE vend_id = 'DLL01' AND prod_price OR 示例 SELECT prod_id, prod_name, prod_price FROM products WHERE vend_id = 'DLL01' OR vend_id = 'BRS01'; NOT 示例 SELECT * FROM products WHERE prod_price NOT BETWEEN 3 AND 5; 3.5 LIKE LIKE 操作符在 WHERE 子句中使用，作用是确定字符串是否匹配模式。 只有字段是文本值时才使用 LIKE。 LIKE 支持两个通配符匹配选项：% 和 _。 不要滥用通配符，通配符位于开头处匹配会非常慢。 % 表示任何字符出现任意次数。 _ 表示任何字符出现一次。 % 示例 SELECT prod_id, prod_name, prod_price FROM products WHERE prod_name LIKE '%bean bag%'; _ 示例 SELECT prod_id, prod_name, prod_price FROM products WHERE prod_name LIKE '__ inch teddy bear'; 4. 连接和组合 4.1 连接（JOIN） 如果一个 JOIN 至少有一个公共字段并且它们之间存在关系，则该 JOIN 可以在两个或多个表上工作。 连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。 JOIN 保持基表（结构和数据）不变。 JOIN 有两种连接类型：内连接和外连接。 内连接又称等值连接，使用 INNER JOIN 关键字。在没有条件语句的情况下返回笛卡尔积。 自连接可以看成内连接的一种，只是连接的表是自身而已。 自然连接是把同名列通过 = 测试连接起来的，同名列可以有多个。 内连接 vs 自然连接 内连接提供连接的列，而自然连接自动连接所有同名列。 外连接返回一个表中的所有行，并且仅返回来自次表中满足连接条件的那些行，即两个表中的列是相等的。外连接分为左外连接、右外连接、全外连接（Mysql 不支持）。 左外连接就是保留左表没有关联的行。 右外连接就是保留右表没有关联的行。 连接 vs 子查询 连接可以替换子查询，并且比子查询的效率一般会更快。 内连接（INNER JOIN） SELECT vend_name, prod_name, prod_price FROM vendors INNER JOIN products ON vendors.vend_id = products.vend_id; 自连接 SELECT c1.cust_id, c1.cust_name, c1.cust_contact FROM customers c1, customers c2 WHERE c1.cust_name = c2.cust_name AND c2.cust_contact = 'Jim Jones'; 自然连接（NATURAL JOIN） SELECT * FROM Products NATURAL JOIN Customers; 左连接（LEFT JOIN） SELECT customers.cust_id, orders.order_num FROM customers LEFT JOIN orders ON customers.cust_id = orders.cust_id; 右连接（RIGHT JOIN） SELECT customers.cust_id, orders.order_num FROM customers RIGHT JOIN orders ON customers.cust_id = orders.cust_id; 4.2 组合（UNION） UNION 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 UNION 中参与查询的提取行。 UNION 基本规则 所有查询的列数和列顺序必须相同。 每个查询中涉及表的列的数据类型必须相同或兼容。 通常返回的列名取自第一个查询。 默认会去除相同行，如果需要保留相同行，使用 UNION ALL。 只能包含一个 ORDER BY 子句，并且必须位于语句的最后。 应用场景 在一个查询中从不同的表返回结构数据。 对一个表执行多个查询，按一个查询返回数据。 组合查询 SELECT cust_name, cust_contact, cust_email FROM customers WHERE cust_state IN ('IL', 'IN', 'MI') UNION SELECT cust_name, cust_contact, cust_email FROM customers WHERE cust_name = 'Fun4All'; 4.3 JOIN vs UNION JOIN vs UNION JOIN 中连接表的列可能不同，但在 UNION 中，所有查询的列数和列顺序必须相同。 UNION 将查询之后的行放在一起（垂直放置），但 JOIN 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。 5. 函数 注意：不同数据库的函数往往各不相同，因此不可移植。本节主要以 Mysql 的函数为例。 5.1 文本处理 函数 说明 LEFT(str, length)、RIGHT(str, length) 返回具有指定长度的字符串的左边或右边部分 LOWER(str)、UPPER(str) 转换为小写或者大写 LTRIM(str)、RTIM(str) 去除左边或者右边的空格 LENGTH(str) 长度 SOUNDEX(str) 转换为语音值 其中， SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式。 SELECT * FROM mytable WHERE SOUNDEX(col1) = SOUNDEX('apple') 5.2 日期和时间处理 日期格式：YYYY-MM-DD 时间格式：HH:MM:SS 函 数 说 明 AddDate() 增加一个日期（天、周等） AddTime() 增加一个时间（时、分等） CurDate() 返回当前日期 CurTime() 返回当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DayOfWeek() 对于一个日期，返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Month() 返回一个日期的月份部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒部分 Time() 返回一个日期时间的时间部分 Year() 返回一个日期的年份部分 5.3 数值处理 函数 说明 SIN() 正弦 COS() 余弦 TAN() 正切 ABS() 绝对值 SQRT() 平方根 MOD() 余数 EXP() 指数 PI() 圆周率 RAND() 随机数 5.4 汇总 函 数 说 明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 AVG() 会忽略 NULL 行。 使用 DISTINCT 可以让汇总函数值汇总不同的值。 SELECT AVG(DISTINCT col1) AS avg_col FROM mytable 6. 排序和分组 6.1 ORDER BY ORDER BY 用于对结果集进行排序。 ASC ：升序（默认） DESC ：降序 可以按多个列进行排序，并且为每个列指定不同的排序方式 指定多个列的排序方向 SELECT * FROM products ORDER BY prod_price DESC, prod_name ASC; 6.2 GROUP BY GROUP BY 子句将记录分组到汇总行中。 GROUP BY 为每个组返回一个记录。 GROUP BY 通常还涉及聚合：COUNT，MAX，SUM，AVG 等。 GROUP BY 可以按一列或多列进行分组。 GROUP BY 按分组字段进行排序后，ORDER BY 可以以汇总字段来进行排序。 分组 SELECT cust_name, COUNT(cust_address) AS addr_num FROM Customers GROUP BY cust_name; 分组后排序 SELECT cust_name, COUNT(cust_address) AS addr_num FROM Customers GROUP BY cust_name ORDER BY cust_name DESC; 6.3 HAVING HAVING 用于对汇总的 GROUP BY 结果进行过滤。 HAVING 要求存在一个 GROUP BY 子句。 WHERE 和 HAVING 可以在相同的查询中。 HAVING vs WHERE WHERE 和 HAVING 都是用于过滤。 HAVING 适用于汇总的组记录；而 WHERE 适用于单个记录。 使用 WHERE 和 HAVING 过滤数据 SELECT cust_name, COUNT(*) AS num FROM Customers WHERE cust_email IS NOT NULL GROUP BY cust_name HAVING COUNT(*) >= 1; 7. 数据定义 DDL 的主要功能是定义数据库对象（如：数据库、数据表、视图、索引等）。 7.1 数据库（DATABASE） 创建数据库 CREATE DATABASE test; 删除数据库 DROP DATABASE test; 选择数据库 USE test; 7.2 数据表（TABLE） 创建数据表 普通创建 CREATE TABLE user ( id int(10) unsigned NOT NULL COMMENT 'Id', username varchar(64) NOT NULL DEFAULT 'default' COMMENT '用户名', password varchar(64) NOT NULL DEFAULT 'default' COMMENT '密码', email varchar(64) NOT NULL DEFAULT 'default' COMMENT '邮箱' ) COMMENT='用户表'; 根据已有的表创建新表 CREATE TABLE vip_user AS SELECT * FROM user; 删除数据表 DROP TABLE user; 修改数据表 添加列 ALTER TABLE user ADD age int(3); 删除列 ALTER TABLE user DROP COLUMN age; 修改列 ALTER TABLE `user` MODIFY COLUMN age tinyint; 添加主键 ALTER TABLE user ADD PRIMARY KEY (id); 删除主键 ALTER TABLE user DROP PRIMARY KEY; 7.3 视图（VIEW） 定义 视图是基于 SQL 语句的结果集的可视化的表。 视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。 作用 简化复杂的 SQL 操作，比如复杂的联结； 只使用实际表的一部分数据； 通过只给用户访问视图的权限，保证数据的安全性； 更改数据格式和表示。 创建视图 CREATE VIEW top_10_user_view AS SELECT id, username FROM user WHERE id 删除视图 DROP VIEW top_10_user_view; 7.4 索引（INDEX） 作用 通过索引可以更加快速高效地查询数据。 用户无法看到索引，它们只能被用来加速查询。 注意 更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。 唯一索引 唯一索引表明此索引的每一个索引值只对应唯一的数据记录。 创建索引 CREATE INDEX user_index ON user (id); 创建唯一索引 CREATE UNIQUE INDEX user_index ON user (id); 删除索引 ALTER TABLE user DROP INDEX user_index; 7.5 约束 SQL 约束用于规定表中的数据规则。 如果存在违反约束的数据行为，行为会被约束终止。 约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。 约束类型 NOT NULL - 指示某列不能存储 NULL 值。 UNIQUE - 保证某列的每行必须有唯一的值。 PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。 FOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。 CHECK - 保证列中的值符合指定的条件。 DEFAULT - 规定没有给列赋值时的默认值。 创建表时使用约束条件： CREATE TABLE Users ( Id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增Id', Username VARCHAR(64) NOT NULL UNIQUE DEFAULT 'default' COMMENT '用户名', Password VARCHAR(64) NOT NULL DEFAULT 'default' COMMENT '密码', Email VARCHAR(64) NOT NULL DEFAULT 'default' COMMENT '邮箱地址', Enabled TINYINT(4) DEFAULT NULL COMMENT '是否有效', PRIMARY KEY (Id) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT='用户表'; 8. 事务处理 不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。 MySQL 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。 通过 set autocommit=0 可以取消自动提交，直到 set autocommit=1 才会提交；autocommit 标记是针对每个连接而不是针对服务器的。 指令 START TRANSACTION - 指令用于标记事务的起始点。 SAVEPOINT - 指令用于创建保留点。 ROLLBACK TO - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 START TRANSACTION 语句处。 COMMIT - 提交事务。 -- 开始事务 START TRANSACTION; -- 插入操作 A INSERT INTO `user` VALUES (1, 'root1', 'root1', 'xxxx@163.com'); -- 创建保留点 updateA SAVEPOINT updateA; -- 插入操作 B INSERT INTO `user` VALUES (2, 'root2', 'root2', 'xxxx@163.com'); -- 回滚到保留点 updateA ROLLBACK TO updateA; -- 提交事务，只有操作 A 生效 COMMIT; 9. 权限控制 GRANT 和 REVOKE 可在几个层次上控制访问权限： 整个服务器，使用 GRANT ALL 和 REVOKE ALL； 整个数据库，使用 ON database.*； 特定的表，使用 ON database.table； 特定的列； 特定的存储过程。 新创建的账户没有任何权限。 账户用 username@host 的形式定义，username@% 使用的是默认主机名。 MySQL 的账户信息保存在 mysql 这个数据库中。 USE mysql; SELECT user FROM user; 复制代码 创建账户 CREATE USER myuser IDENTIFIED BY 'mypassword'; 修改账户名 UPDATE user SET user='newuser' WHERE user='myuser'; FLUSH PRIVILEGES; 删除账户 DROP USER myuser; 查看权限 SHOW GRANTS FOR myuser; 授予权限 GRANT SELECT, INSERT ON *.* TO myuser; 删除权限 REVOKE SELECT, INSERT ON *.* FROM myuser; 更改密码 SET PASSWORD FOR myuser = 'mypass'; 10. 存储过程 存储过程可以看成是对一系列 SQL 操作的批处理； 使用存储过程的好处 代码封装，保证了一定的安全性； 代码复用； 由于是预先编译，因此具有很高的性能。 创建存储过程 命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。 包含 in、out 和 inout 三种参数。 给变量赋值都需要用 select into 语句。 每次只能给一个变量赋值，不支持集合的操作。 创建存储过程 DROP PROCEDURE IF EXISTS `proc_adder`; DELIMITER ;; CREATE DEFINER=`root`@`localhost` PROCEDURE `proc_adder`(IN a int, IN b int, OUT sum int) BEGIN DECLARE c int; if a is null then set a = 0; end if; if b is null then set b = 0; end if; set sum = a + b; END ;; DELIMITER ; 使用存储过程 set @b=5; call proc_adder(2,@b,@s); select @s as sum; 11. 游标 游标（cursor）是一个存储在 DBMS 服务器上的数据库查询，它不是一条 SELECT 语句，而是被该语句检索出来的结果集。 在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。 使用游标的四个步骤： 声明游标，这个过程没有实际检索出数据； 打开游标； 取出数据； 关闭游标； DELIMITER $ CREATE PROCEDURE getTotal() BEGIN DECLARE total INT; -- 创建接收游标数据的变量 DECLARE sid INT; DECLARE sname VARCHAR(10); -- 创建总数变量 DECLARE sage INT; -- 创建结束标志变量 DECLARE done INT DEFAULT false; -- 创建游标 DECLARE cur CURSOR FOR SELECT id,name,age from cursor_table where age>30; -- 指定游标循环结束时的返回值 DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = true; SET total = 0; OPEN cur; FETCH cur INTO sid, sname, sage; WHILE(NOT done) DO SET total = total + 1; FETCH cur INTO sid, sname, sage; END WHILE; CLOSE cur; SELECT total; END $ DELIMITER ; -- 调用存储过程 call getTotal(); 12. 触发器 触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。 可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。 MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程。 BEGIN 和 END 当触发器的触发条件满足时，将会执行 BEGIN 和 END 之间的触发器执行动作。 🔔 注意：在 MySQL 中，分号 ; 是语句结束的标识符，遇到分号表示该段语句已经结束，MySQL 可以开始执行了。因此，解释器遇到触发器执行动作中的分号后就开始执行，然后会报错，因为没有找到和 BEGIN 匹配的 END。 这时就会用到 DELIMITER 命令（DELIMITER 是定界符，分隔符的意思）。它是一条命令，不需要语句结束标识，语法为：DELIMITER new_delemiter。new_delemiter 可以设为 1 个或多个长度的符号，默认的是分号 ;，我们可以把它修改为其他符号，如 $ - DELIMITER $ 。在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了 $，才认为是语句结束。注意，使用完之后，我们还应该记得把它给修改回来。 NEW 和 OLD MySQL 中定义了 NEW 和 OLD 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。 在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据； 在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据； 在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据； 使用方法： NEW.columnName （columnName 为相应数据表某一列名） 12.1 创建触发器 提示：为了理解触发器的要点，有必要先了解一下创建触发器的指令。 CREATE TRIGGER 指令用于创建触发器。 语法： CREATE TRIGGER trigger_name trigger_time trigger_event ON table_name FOR EACH ROW BEGIN trigger_statements END; 说明： trigger_name：触发器名 trigger_time: 触发器的触发时机。取值为 BEFORE 或 AFTER。 trigger_event: 触发器的监听事件。取值为 INSERT、UPDATE 或 DELETE。 table_name: 触发器的监听目标。指定在哪张表上建立触发器。 FOR EACH ROW: 行级监视，Mysql 固定写法，其他 DBMS 不同。 trigger_statements: 触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 ; 来结尾 示例： DELIMITER $ CREATE TRIGGER `trigger_insert_user` AFTER INSERT ON `user` FOR EACH ROW BEGIN INSERT INTO `user_history`(user_id, operate_type, operate_time) VALUES (NEW.id, 'add a user', now()); END $ DELIMITER ; 12.2 查看触发器 SHOW TRIGGERS; 12.3 删除触发器 DROP TRIGGER IF EXISTS trigger_insert_user; "},"java/mysql.html":{"url":"java/mysql.html","title":"MySQL语法","keywords":"","body":""},"android/android.html":{"url":"android/android.html","title":"Android","keywords":"","body":"hello android System.out.println(\"sdfdf\"); System.out.println(\"sdfdf\"); System.out.println(\"sdfdf\"); System.out.println(\"sdfdf\"); System.out.println(\"sdfdf\"); System.out.println(\"sdfdf\"); System.out.println(\"sdfdf\"); "},"kotlin/kotlin.html":{"url":"kotlin/kotlin.html","title":"Kotlin","keywords":"","body":"Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift，由 JetBrains 设计开发并开源。 Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。 在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。 "},"kotlin/basic_syntax.html":{"url":"kotlin/basic_syntax.html","title":"基本语法","keywords":"","body":"基本语法 包的定义与导入 包的声明应处于源文件顶部： package my.demo import kotlin.text.* // …… 目录与包的结构无需匹配：源代码可以在文件系统的任意位置。 程序入口点 Kotlin 应用程序的入口点是 main 函数。 fun main() { println(\"Hello world!\") } 函数 带有两个 Int 参数、返回 Int 的函数： fun sum(a: Int, b: Int): Int { return a + b } 将表达式作为函数体、返回值类型自动推断的函数： fun sum(a: Int, b: Int) = a + b 函数返回无意义的值： fun printSum(a: Int, b: Int): Unit { println(\"sum of $a and $b is ${a + b}\") } Unit 返回类型可以省略： fun printSum(a: Int, b: Int) { println(\"sum of $a and $b is ${a + b}\") } 变量 定义只读局部变量使用关键字 val 定义。只能为其赋值一次。 val a: Int = 1 // 立即赋值 val b = 2 // 自动推断出 `Int` 类型 val c: Int // 如果没有初始值类型不能省略 c = 3 // 明确赋值 可重新赋值的变量使用 var 关键字： var x = 5 // 自动推断出 `Int` 类型 x += 1 顶层变量： val PI = 3.14 var x = 0 fun incrementX() { x += 1 } 注释 与大多数现代语言一样，Kotlin 支持单行（或行末）与多行（块）注释。 // 这是一个行注释 /* 这是一个多行的 块注释。 */ Kotlin 中的块注释可以嵌套。 /* 注释从这里开始 /* 包含嵌套的注释 */ 并且在这里结束。 */ 字符串模板 var a = 1 // 模板中的简单名称： val s1 = \"a is $a\" a = 2 // 模板中的任意表达式： val s2 = \"${s1.replace(\"is\", \"was\")}, but now is $a\" 条件表达式 fun maxOf(a: Int, b: Int): Int { if (a > b) { return a } else { return b } } 在 Kotlin 中，if 也可以用作表达式： fun maxOf(a: Int, b: Int) = if (a > b) a else b 空值与 null 检测 当某个变量的值可以为 null 的时候，必须在声明处的类型后添加 ? 来标识该引用可为空。 如果 str 的内容不是数字返回 null： fun parseInt(str: String): Int? { // …… } 使用返回可空值的函数: fun printProduct(arg1: String, arg2: String) { val x = parseInt(arg1) val y = parseInt(arg2) // 直接使用 `x * y` 会导致编译错误，因为它们可能为 null if (x != null && y != null) { // 在空检测后，x 与 y 会自动转换为非空值（non-nullable） println(x * y) } else { println(\"'$arg1' or '$arg2' is not a number\") } } 或者 // …… if (x == null) { println(\"Wrong number format in arg1: '$arg1'\") return } if (y == null) { println(\"Wrong number format in arg2: '$arg2'\") return } // 在空检测后，x 与 y 会自动转换为非空值 println(x * y) 类型检测与自动类型转换 is 运算符检测一个表达式是否某类型的一个实例。 如果一个不可变的局部变量或属性已经判断出为某类型，那么检测后的分支中可以直接当作该类型使用，无需显式转换： fun getStringLength(obj: Any): Int? { if (obj is String) { // `obj` 在该条件分支内自动转换成 `String` return obj.length } // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型 return null } 或者 fun getStringLength(obj: Any): Int? { if (obj !is String) return null // `obj` 在这一分支自动转换为 `String` return obj.length } 甚至 fun getStringLength(obj: Any): Int? { // `obj` 在 `&&` 右边自动转换成 `String` 类型 if (obj is String && obj.length > 0) { return obj.length } return null } for 循环 val items = listOf(\"apple\", \"banana\", \"kiwifruit\") for (item in items) { println(item) } 或者 val items = listOf(\"apple\", \"banana\", \"kiwifruit\") for (index in items.indices) { println(\"item at $index is ${items[index]}\") } while 循环 val items = listOf(\"apple\", \"banana\", \"kiwifruit\") var index = 0 while (index when 表达式 fun describe(obj: Any): String = when (obj) { 1 -> \"One\" \"Hello\" -> \"Greeting\" is Long -> \"Long\" !is String -> \"Not a string\" else -> \"Unknown\" } 使用区间（range） 使用 in 运算符来检测某个数字是否在指定区间内： val x = 10 val y = 9 if (x in 1..y+1) { println(\"fits in range\") } 检测某个数字是否在指定区间外: val list = listOf(\"a\", \"b\", \"c\") if (-1 !in 0..list.lastIndex) { println(\"-1 is out of range\") } if (list.size !in list.indices) { println(\"list size is out of valid list indices range, too\") } 区间迭代: for (x in 1..5) { print(x) } 或数列迭代： for (x in 1..10 step 2) { print(x) } println() for (x in 9 downTo 0 step 3) { print(x) } 集合 对集合进行迭代: for (item in items) { println(item) } 使用 in 运算符来判断集合内是否包含某实例： when { \"orange\" in items -> println(\"juicy\") \"apple\" in items -> println(\"apple is fine too\") } 使用 lambda 表达式来过滤（filter）与映射（map）集合： val fruits = listOf(\"banana\", \"avocado\", \"apple\", \"kiwifruit\") fruits .filter { it.startsWith(\"a\") } .sortedBy { it } .map { it.toUpperCase() } .forEach { println(it) } 创建基本类及其实例 val rectangle = Rectangle(5.0, 2.0) val triangle = Triangle(3.0, 4.0, 5.0) "},"kotlin/idiomatic_usage.html":{"url":"kotlin/idiomatic_usage.html","title":"习惯用法","keywords":"","body":"习惯用法 一些在 Kotlin 中广泛使用的语法习惯。 创建 DTOs（POJOs/POCOs） data class Customer(val name: String, val email: String) 会为 Customer 类提供以下功能： 所有属性的 getters （对于 var 定义的还有 setters） equals() hashCode() toString() copy() 所有属性的 component1()、 component2()……等等（参见数据类） 函数的默认参数 fun foo(a: Int = 0, b: String = \"\") { …… } 过滤 list val positives = list.filter { x -> x > 0 } 或者可以更短: val positives = list.filter { it > 0 } 检测元素是否存在于集合中 if (\"john@example.com\" in emailsList) { …… } if (\"jane@example.com\" !in emailsList) { …… } 字符串内插 println(\"Name $name\") 类型判断 when (x) { is Foo //-> …… is Bar //-> …… else //-> …… } 遍历 map/pair 型 list for ((k, v) in map) { println(\"$k -> $v\") } k、v 可以改成任意名字。 使用区间 for (i in 1..100) { …… } // 闭区间：包含 100 for (i in 1 until 100) { …… } // 半开区间：不包含 100 for (x in 2..10 step 2) { …… } for (x in 10 downTo 1) { …… } if (x in 1..10) { …… } 只读 list val list = listOf(\"a\", \"b\", \"c\") 只读 map val map = mapOf(\"a\" to 1, \"b\" to 2, \"c\" to 3) 访问 map println(map[\"key\"]) map[\"key\"] = value 延迟属性 val p: String by lazy { // 计算该字符串 } 扩展函数 fun String.spaceToCamelCase() { …… } \"Convert this to camelcase\".spaceToCamelCase() 创建单例 object Resource { val name = \"Name\" } If not null 缩写 val files = File(\"Test\").listFiles() println(files?.size) If not null and else 缩写 val files = File(\"Test\").listFiles() println(files?.size ?: \"empty\") if null 执行一个语句 val values = …… val email = values[\"email\"] ?: throw IllegalStateException(\"Email is missing!\") 在可能会空的集合中取第一元素 val emails = …… // 可能会是空集合 val mainEmail = emails.firstOrNull() ?: \"\" if not null 执行代码 val value = …… value?.let { …… // 代码会执行到此处, 假如data不为null } 映射可空值（如果非空的话） val value = …… val mapped = value?.let { transformValue(it) } ?: defaultValue // 如果该值或其转换结果为空，那么返回 defaultValue。 返回 when 表达式 fun transform(color: String): Int { return when (color) { \"Red\" -> 0 \"Green\" -> 1 \"Blue\" -> 2 else -> throw IllegalArgumentException(\"Invalid color param value\") } } try/catch 表达式 fun test() { val result = try { count() } catch (e: ArithmeticException) { throw IllegalStateException(e) } // 使用 result } if 表达式 fun foo(param: Int) { val result = if (param == 1) { \"one\" } else if (param == 2) { \"two\" } else { \"three\" } } 返回类型为 Unit 的方法的 Builder 风格用法 fun arrayOfMinusOnes(size: Int): IntArray { return IntArray(size).apply { fill(-1) } } 单表达式函数 fun theAnswer() = 42 等价于 fun theAnswer(): Int { return 42 } 单表达式函数与其它惯用法一起使用能简化代码，例如和 when 表达式一起使用： fun transform(color: String): Int = when (color) { \"Red\" -> 0 \"Green\" -> 1 \"Blue\" -> 2 else -> throw IllegalArgumentException(\"Invalid color param value\") } 对一个对象实例调用多个方法 （with） class Turtle { fun penDown() fun penUp() fun turn(degrees: Double) fun forward(pixels: Double) } val myTurtle = Turtle() with(myTurtle) { // 画一个 100 像素的正方形 penDown() for (i in 1..4) { forward(100.0) turn(90.0) } penUp() } 配置对象的属性（apply） val myRectangle = Rectangle().apply { length = 4 breadth = 5 color = 0xFAFAFA } 这对于配置未出现在对象构造函数中的属性非常有用。 Java 7 的 try with resources val stream = Files.newInputStream(Paths.get(\"/some/file.txt\")) stream.buffered().reader().use { reader -> println(reader.readText()) } 对于需要泛型信息的泛型函数的适宜形式 // public final class Gson { // …… // public T fromJson(JsonElement json, Class classOfT) throws JsonSyntaxException { // …… inline fun Gson.fromJson(json: JsonElement): T = this.fromJson(json, T::class.java) 使用可空布尔 val b: Boolean? = …… if (b == true) { …… } else { // b 是 false 或者 null } 交换两个变量 var a = 1 var b = 2 a = b.also { b = a } TODO()：将代码标记为不完整 Kotlin 的标准库有一个 TODO() 函数，该函数总是抛出一个 NotImplementedError。 其返回类型为 Nothing，因此无论预期类型是什么都可以使用它。 还有一个接受原因参数的重载： fun calcTaxes(): BigDecimal = TODO(\"Waiting for feedback from accounting\") IntelliJ IDEA 的 kotlin 插件理解 TODO() 的语言，并且会自动在 TODO 工具窗口中添加代码指示。 "},"kotlin/coding_standards.html":{"url":"kotlin/coding_standards.html","title":"编码规范","keywords":"","body":"编码规范 本页包含当前 Kotlin 语言的编码风格。 源代码组织 目录结构 在纯 Kotlin 项目中，推荐的目录结构遵循省略了公共根包的包结构。例如，如果项目中的所有代码都位于 org.example.kotlin 包及其子包中，那么org.example.kotlin 包的文件应该直接放在源代码根目录下，而 org.example.kotlin.network.socket 中的文件应该放在源代码根目录下的 network/socket 子目录中。 对于 JVM 平台：Kotlin 源文件应当与 Java 源文件位于同一源文件根目录下， 并遵循相同的目录结构（每个文件应存储在与其 package 语句对应的目录中。 源文件名称 如果 Kotlin 文件包含单个类（以及可能相关的顶层声明），那么文件名应该与该类的名称相同，并追加 .kt 扩展名。如果文件包含多个类或只包含顶层声明， 那么选择一个描述该文件所包含内容的名称，并以此命名该文件。 使用首字母大写的驼峰风格（也称为 Pascal 风格）， 例如 ProcessDeclarations.kt。 文件的名称应该描述文件中代码的作用。因此，应避免在文件名中使用诸如“Util”之类的无意义词语。 源文件组织 鼓励多个声明（类、顶级函数或者属性）放在同一个 Kotlin 源文件中， 只要这些声明在语义上彼此紧密关联并且文件保持合理大小 （不超过几百行）。 特别是在为类定义与类的所有客户都相关的扩展函数时， 请将它们放在与类自身定义相同的地方。而在定义仅对指定客户有意义的扩展函数时，请将它们放在紧挨该客户代码之后。不要只是为了保存 “Foo 的所有扩展函数”而创建文件。 类布局 通常，一个类的内容按以下顺序排列： 属性声明与初始化块 次构造函数 方法声明 伴生对象 不要按字母顺序或者可见性对方法声明排序，也不要将常规方法与扩展方法分开。而是要把相关的东西放在一起，这样从上到下阅读类的人就能够跟进所发生事情的逻辑。选择一个顺序（高级别优先，或者相反）并坚持下去。 将嵌套类放在紧挨使用这些类的代码之后。如果打算在外部使用嵌套类，而且类中并没有引用这些类，那么把它们放到末尾，在伴生对象之后。 接口实现布局 在实现一个接口时，实现成员的顺序应该与该接口的成员顺序相同（如果需要， 还要插入用于实现的额外的私有方法） 重载布局 在类中总是将重载放在一起。 命名规则 在 Kotlin 中，包名与类名的命名规则非常简单： 包的名称总是小写且不使用下划线（org.example.project）。 通常不鼓励使用多个词的名称，但是如果确实需要使用多个词，可以将它们连接在一起或使用驼峰风格（org.example.myProject）。 类与对象的名称以大写字母开头并使用驼峰风格： open class DeclarationProcessor { /*……*/ } object EmptyDeclarationProcessor : DeclarationProcessor() { /*……*/ } 函数名 函数、属性与局部变量的名称以小写字母开头、使用驼峰风格而不使用下划线： fun processDeclarations() { /*……*/ } var declarationCount = 1 例外：用于创建类实例的工厂函数可以与抽象返回类型具有相同的名称： interface Foo { /*……*/ } class FooImpl : Foo { /*……*/ } fun Foo(): Foo { return FooImpl() } 测试方法的名称 当且仅当在测试中，可以使用反引号括起来的带空格的方法名。 （请注意，Android 运行时目前不支持这样的方法名。）测试代码中也允许方法名使用下划线。 class MyTestCase { @Test fun `ensure everything works`() { /*...*/ } @Test fun ensureEverythingWorks_onAndroid() { /*...*/ } } 属性名 常量名称（标有 const 的属性，或者保存不可变数据的没有自定义 get 函数的顶层/对象 val 属性）应该使用大写、下划线分隔的名称 (screaming snake case) names: const val MAX_COUNT = 8 val USER_NAME_FIELD = \"UserName\" 保存带有行为的对象或者可变数据的顶层/对象属性的名称应该使用驼峰风格名称： val mutableCollection: MutableSet = HashSet() 保存单例对象引用的属性的名称可以使用与 object 声明相同的命名风格： val PersonComparator: Comparator = /*...*/ 对于枚举常量，可以使用大写、下划线分隔的名称 (screaming snake case) （enum class Color { RED, GREEN }）也可使用首字母大写的常规驼峰名称，具体取决于用途。 幕后属性的名称 如果一个类有两个概念上相同的属性，一个是公共 API 的一部分，另一个是实现细节，那么使用下划线作为私有属性名称的前缀： class C { private val _elementList = mutableListOf() val elementList: List get() = _elementList } 选择好名称 类的名称通常是用来解释类是什么的名词或者名词短语：List、 PersonReader。 方法的名称通常是动词或动词短语，说明该方法做什么：close、 readPersons。 修改对象或者返回一个新对象的名称也应遵循建议。例如 sort 是对一个集合就地排序，而 sorted 是返回一个排序后的集合副本。 名称应该表明实体的目的是什么，所以最好避免在名称中使用无意义的单词 （Manager、 Wrapper 等）。 当使用首字母缩写作为名称的一部分时，如果缩写由两个字母组成，就将其大写（IOStream）； 而如果缩写更长一些，就只大写其首字母（XmlFormatter、 HttpInputStream）。 格式化 使用 4 个空格缩进。不要使用 tab。 对于花括号，将左花括号放在结构起始处的行尾，而将右花括号放在与左括结构横向对齐的单独一行。 if (elements != null) { for (element in elements) { // …… } } 在 Kotlin 中，分号是可选的，因此换行很重要。语言设计采用 Java 风格的花括号格式，如果尝试使用不同的格式化风格，那么可能会遇到意外的行为。 横向空白 在二元操作符左右留空格（a + b）。例外：不要在 “range to” 操作符（0..i）左右留空格。 不要在一元运算符左右留空格（a++） 在控制流关键字（if、 when、 for 以及 while）与相应的左括号之间留空格。 不要在主构造函数声明、方法声明或者方法调用的左括号之前留空格。 class A(val x: Int) fun foo(x: Int) { …… } fun bar() { foo(1) } 绝不在 (、 [ 之后或者 ]、 ) 之前留空格。 绝不在. 或者 ?. 左右留空格：foo.bar().filter { it > 2 }.joinToString(), foo?.bar() 在 // 之后留一个空格：// 这是一条注释 不要在用于指定类型参数的尖括号前后留空格：class Map { …… } 不要在 :: 前后留空格：Foo::class、 String::length 不要在用于标记可空类型的 ? 前留空格：String? 作为一般规则，避免任何类型的水平对齐。将标识符重命名为不同长度的名称不应该影响声明或者任何用法的格式。 冒号 在以下场景中的 : 之前留一个空格： 当它用于分隔类型与超类型时； 当委托给一个超类的构造函数或者同一类的另一个构造函数时； 在 object 关键字之后。 而当分隔声明与其类型时，不要在 : 之前留空格。 在 : 之后总要留一个空格。 abstract class Foo : IFoo { abstract fun foo(a: Int): T } class FooImpl : Foo() { constructor(x: String) : this(x) { /*……*/ } val x = object : IFoo { /*……*/ } } 类头格式化 具有少数主构造函数参数的类可以写成一行： class Person(id: Int, name: String) 具有较长类头的类应该格式化，以使每个主构造函数参数都在带有缩进的独立的行中。 另外，右括号应该位于一个新行上。如果使用了继承，那么超类的构造函数调用或者所实现接口的列表应该与右括号位于同一行： class Person( id: Int, name: String, surname: String ) : Human(id, name) { /*……*/ } 对于多个接口，应该将超类构造函数调用放在首位，然后将每个接口应放在不同的行中： class Person( id: Int, name: String, surname: String ) : Human(id, name), KotlinMaker { /*……*/ } 对于具有很长超类型列表的类，在冒号后面换行，并横向对齐所有超类型名： class MyFavouriteVeryLongClassHolder : MyLongHolder(), SomeOtherInterface, AndAnotherOne { fun foo() { /*...*/ } } 为了将类头与类体分隔清楚，当类头很长时，可以在类头后放一空行 （如上例所示）或者将左花括号放在独立行上： class MyFavouriteVeryLongClassHolder : MyLongHolder(), SomeOtherInterface, AndAnotherOne { fun foo() { /*...*/ } } 构造函数参数使用常规缩进（4 个空格）。 理由：这确保了在主构造函数中声明的属性与 在类体中声明的属性具有相同的缩进。 修饰符 如果一个声明有多个修饰符，请始终按照以下顺序安放： public / protected / private / internal expect / actual final / open / abstract / sealed / const external override lateinit tailrec vararg suspend inner enum / annotation / fun // 在 `fun interface` 中是修饰符 companion inline infix operator data 将所有注解放在修饰符前： @Named(\"Foo\") private val foo: Foo 除非你在编写库，否则请省略多余的修饰符（例如 public）。 注解格式化 注解通常放在单独的行上，在它们所依附的声明之前，并使用相同的缩进： @Target(AnnotationTarget.PROPERTY) annotation class JsonExclude 无参数的注解可以放在同一行： @JsonExclude @JvmField var x: String 无参数的单个注解可以与相应的声明放在同一行： @Test fun foo() { /*……*/ } 文件注解 文件注解位于文件注释（如果有的话）之后、package 语句之前，并且用一个空白行与 package 分开（为了强调其针对文件而不是包）。 /** 授权许可、版权以及任何其他内容 */ @file:JvmName(\"FooBar\") package foo.bar 函数格式化 如果函数签名不适合单行，请使用以下语法： fun longMethodName( argument: ArgumentType = defaultValue, argument2: AnotherArgumentType, ): ReturnType { // 函数体 } 函数参数使用常规缩进（4 个空格）。 理由：与构造函数参数一致 对于由单个表达式构成的函数体，优先使用表达式形式。 fun foo(): Int { // 不良 return 1 } fun foo() = 1 // 良好 表达式函数体格式化 如果函数的表达式函数体与函数声明不适合放在同一行，那么将 = 留在第一， 并将表达式函数体缩进 4 个空格。 fun f(x: String, y: String, z: String) = veryLongFunctionCallWithManyWords(andLongParametersToo(), x, y, z) 属性格式化 对于非常简单的只读属性，请考虑单行格式： val isEmpty: Boolean get() = size == 0 对于更复杂的属性，总是将 get 与 set 关键字放在不同的行上： val foo: String get() { /*……*/ } 对于具有初始化器的属性，如果初始化器很长，那么在等号后增加一个换行并将初始化器缩进四个空格： private val defaultCharset: Charset? = EncodingRegistry.getInstance().getDefaultCharsetForPropertiesFiles(file) 格式化控制流语句 如果 if 或 when 语句的条件有多行，那么在语句体外边总是使用大括号。 将该条件的每个后续行相对于条件语句起始处缩进 4 个空格。 将该条件的右圆括号与左花括号放在单独一行： if (!component.isSyncing && !hasAnyKotlinRuntimeInScope(module) ) { return createKotlinNotConfiguredPanel(module) } 理由：对齐整齐并且将条件与语句体分隔清楚 将 else、 catch、 finally 关键字以及 do/while 循环的 while 关键字与之前的花括号放在相同的行上： if (condition) { // 主体 } else { // else 部分 } try { // 主体 } finally { // 清理 } 在 when 语句中，如果一个分支不止一行，可以考虑用空行将其与相邻的分支块分开： private fun parsePropertyValue(propName: String, token: Token) { when (token) { is Token.ValueToken -> callback.visitValue(propName, token.value) Token.LBRACE -> { // …… } } } 将短分支放在与条件相同的行上，无需花括号。 when (foo) { true -> bar() // 良好 false -> { baz() } // 不良 } 方法调用格式化 在较长参数列表的左括号后添加一个换行符。按 4 个空格缩进参数。 将密切相关的多个参数分在同一行。 drawSquare( x = 10, y = 10, width = 100, height = 100, fill = true ) 在分隔参数名与值的 = 左右留空格。 链式调用换行 当对链式调用换行时，将 . 字符或者 ?. 操作符放在下一行，并带有单倍缩进： val anchor = owner ?.firstChild!! .siblings(forward = true) .dropWhile { it is PsiComment || it is PsiWhiteSpace } 调用链的第一个调用通常在换行之前，当然如果能让代码更有意义也可以忽略这点。 Lambda 表达式格式化 在 lambda 表达式中，应该在花括号左右以及分隔参数与代码体的箭头左右留空格。 如果一个调用接受单个 lambda 表达式，应该尽可能将其放在圆括号外边传入。 list.filter { it > 10 } 如果为 lambda 表达式分配一个标签，那么不要在该标签与左花括号之间留空格： fun foo() { ints.forEach lit@{ // …… } } 在多行的 lambda 表达式中声明参数名时，将参数名放在第一行，后跟箭头与换行符： appendCommaSeparated(properties) { prop -> val propertyValue = prop.get(obj) // …… } 如果参数列表太长而无法放在一行上，请将箭头放在单独一行： foo { context: Context, environment: Env -> context.configureEnv(environment) } 尾随逗号 尾随逗号是一系列元素的最后一项之后的逗号符号： class Person( val firstName: String, val lastName: String, val age: Int, // trailing comma ) 文档注释 避免重复结构 语言特性的惯用法 库的编码规范 "},"linux/linux.html":{"url":"linux/linux.html","title":"Linux","keywords":"","body":""},"framework/framework.html":{"url":"framework/framework.html","title":"框架","keywords":"","body":""},"tools/tools.html":{"url":"tools/tools.html","title":"工具","keywords":"","body":" xxx yyy zzzz xxx "}}